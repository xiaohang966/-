# 函数function

> - 函数可以封装一段代码，让代码重复使用，并且使用非常灵活
> - 函数就是一个可重复使用的代码块
> - 是一种复杂的数据类型



## 函数的参数

> 当一个函数中，某些数据会发生改变时，可以使用参数

**区别**

- **形参**：函数体小括号中的参数，多个参数使用逗号分隔
  - 作用：用来给实参占位置，会在调用后接收实参值进行操作
- **实参**：调用的小括号中的参数，多个参数使用逗号分隔
  - 作用：用来给形参设置实际值使用



## 函数的返回值

> 含义：函数的返回值指的是函数的结果

作用：让函数内的计算结果可以被外界操作

- **函数中的变量无法直接**在函数外使用
  - Uncaught ReferenceError: sum is not defined 说明没有sum的声明

- **格式：**
  - return 值;
- **接收方式：**
  - 通过函数的调用表达式接收：
    - var 变量 = 函数名();   // 变量结果就是返回值
    - console.log( 函数名() ); // 调用表达式本身也代表返回值，不保存也可以使用
- **return的第二个功能**：结束函数执行
  - return可以单独使用，仅仅表示结束函数
- **函数没设置返回值，默认为undefined**

#  函数的默认值

> 当函数有形参，而没有传入实参，那么可以指定一个值 为默认值

- **正常写法：**

```js
function fun(name){
	// 指定函数的默认值，在没有传入实参，而函数还被调用了
	name =name || 'jack'
	console.log(name)
}
fun('rose') //rose
fun() // jack
```



- **ES6提供的**

```js
// 此时函数的默认值是 jack 这是在没有传入实参的时候默认显示的
function fun(name='jack'){
	console.log(name)
}
fun('rose') //rose
fun() // jack
```



 函数参数的解构赋值版本

> 优化代码，ES6 提供的写法

```js
// 封装的方法 :设置type的默认值为 get(在不type传入参数的时候)
function ajax({url type='get',data,success}){
	// 封装使用
	 $.ajax({url type,data,success}})
}

// 函数调用方法
ajxa({
	url：'地址'，
	type：'方法',
	data:{
	}
})
```

> 当用户使用 解构赋值版本的函数 如果在没有传入实参的时候，此时调用会报

**为了不出现这种错误 那么结合使用**

- `函数的参数={}`:此时如果有函数的默认值，那这个式子就相当于访问函数的默认值 不会报错

```
function ajax({url,type='get',data,success = {} 
}){
	// 封装使用
	 $.ajax({url type,data,success}})
}
```







# 函数声明方式（调用方式）

> 函数不调用就不会执行，任意需要的位置进行调用，表示在调用位置执行函数内的代码。
>
> - 格式：   函数名();



## 声明函数

>声明变量一样

```js
var 函数名 = function(参数){
 	函数体
}
// 函数名()
```



## 命名函数

> 相当于给函数 自定义一个名字

```js
function 函数名() {
    // 函数体
};
 调用
// 函数名() 
```



## 匿名函数

> 匿名函数就是没有名字的函数

```js
function (参数){
  函数体
}
// 在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用：
    var fn = function(a,b){
      return a + b;
  }  
   调用
// 函数名()
```



## 自调用函数

> 自调用函数 是对匿名函数的一种特殊使用方式

- 效果：在书写的位置执行一次

- 作用：
  - 减少全局变量的使用

    `解释：如果所有变量都是全局的，变量的查找速度就会降低`

```js
(function () {
    
})();
// 定义之后，立刻调用
// 强调：自调用函数后的分号必须加
```



## arguments（伪数组）

> 设置的实参个数不确定，正常通过形参无法接受，可以使用arguments

- arguments**不是真正的数组**，它是称为**伪数组或类数组**
- 具有**数组**的索引和长度，但是不具有数组的一些特殊方法(例如push)

`arguments这个东西只能在函数内部使用，也不需要声明，只要在函数中直接使用就行`

```js
// arguments这个东西就解决了我们要求n个数字的和的问题
function getSum(){
  var sum = 0;
  for(var i = 0; i < arguments.length ; i++){
    sum += arguments[i];
  }
  return sum;
}

getSum(1,2,3);// 输出 6
getSum(1,2,3,4,5); // 输出15
```





# 回调函数

含义：指的是某个函数作为参数使用的形式。

- 注意：回调函数使用命名函数和匿名函数均可，没有本质区别

# 递归函数

递归函数(简介，能知道，能认识即可)：

- 含义：指的是某个函数在内部调用自身的形式。

# 闭包函数



# 函数的使用

## 事件

> 事件是一种 函数 function 的一种使用方法， 指的是操作用户在 做指定的行动的时候，做出的一系列的反应



### 书写事件的两种方法

- **注册事件：别称 DOM0级事件**
  - **语法：** `ele.on+事件类型 = 函数/匿名函数(就是function)`
  - **特点：**同类型事件只能绑定一次，多次绑定只有最后一次绑定有效
  - 事件可以完成之后，可以在其他的作用上 进行二次使用：` btn.onclick()`



- **注册事件：别称DOM 2级事件**
  - **语法：**`ele.addEventListener('事件类型',匿名函数/函数名)`
  - **特点：** 元素绑定事件，可以**多次**绑定同类型事件，执行顺序从上到下



### 解除事件绑定的两种方法

- **DOM0级事件的解除方法**
  - **语法：** `ele.on+事件类型=null`
  - 只要是DOM0级事件 就可以直接解除



- **DOM2级事件的解除**
  - **语法：** `ele.removerEventListener('事件类型',函数名)`



### 事件类型(常用)

> 相当于封装好的方法，按照指定的格式去使用，用特定的`函数类型`
>
> 然后在 `function` 中写上对应代码，就可以完成指定事情。

- 事件的使用范围，以及如何的使用

- **鼠标事件**
  - **点击事件：**`click`
  - **双击事件：**`dblclick`


