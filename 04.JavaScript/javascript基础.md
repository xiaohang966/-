# javaScript基础



## 基本包装类型对象

`正常来说字符串,数组 这些基本类型应该没有属性和方法`

- **解释：**
  -  **基本类型就是没有属性和方法的**
  -  **js为了方便我们操作基本类型，js会自动创建一个对象**
  -  **所以书写的属性和方法,实际上是这个对象的属性和方法**
  -  **当操作完毕，js会自动将这个对象清除** (js垃圾回收机制)
- **小结：**
  - **创建一个字符串的对象,其实就是类似new String()创建的对象，称为基本包装类型对象(包装对象）**
  -  **包装对象的作用,是用来辅助基本类型进行属性方法操作用的**
  - **正常书写时，不需要书写这种代码**
    - `js自动会执行这些操作，我们没必要写`
    - **自己书写会导致不必要的问题**





### 在浏览器中输入输出的方法

是**window** 对象提供的方法 实际操作的时候 可以不用  **window**

```JavaScript
alert  // 弹出框(提示框)

console.log() //在浏览器的控制台中输出内容
console.dir() // 进阶 扩号中输入详细的内容

document.write() // 将内容输出到页面文档上

prompt()  // 输入框  弹框 输入内容
		  // 参数1： 提示   
		  // 参数2： 输入栏中默认像是的内容
```



## 变量

> js中 保存数据的方法(当然它是临时的)

**变量名不能乱起**

- 两个变量中的值 互换  

`变量1 = 变量3 ，变量1=变量2，变量3=变量1`



- 变量名依次可以声明多个,用逗号隔开

`var a = 10,b=20,c`



## 数据类型	

### 简单数据：5个

#### 数值（number）类型

- 正常数值：0,25,5,3 （这是正常数据）
  - 特殊数值：NaN 非数值
  

#### 字符串（string)类型

- 一种固定显示数据的格式：**单引号 /  双引号 进行包裹**

```js
var a = 'acb'
var a = "acd"
```

- 转义符

> 字符串中不能出现 同样的引号 **二次嵌套的情况** ，但是转义符可以可以允许这样的事情的存在

```js
console.log("小明说：\"小红真漂亮 "\ " )  //用反斜线隔开 就不会报错
```



#### 布尔(boolean)类型

- boolean：判断公式结果的对和错

  - false：不成立
  - true ：成立


#### undefined

只有一个值，undefned,表示变量定义，没有赋值

```js
var a 
console.log(a) //  输出为 undefined 此时 a 为 未定义
```



#### null

只有一个值，null ，表示数据为空(**空在js中也是一个对象**)

```javascript
var a = null //表示这个数据为空
```



### 复杂数据类型

#### 数组 : Array

> 同时保存多个数据

- 数组中保存的多个数据，这些数据被称为 **数据的元素**

```js
// 数组的声明方法
var arr = [1,2,3,4]  （非常常用）
var arr = new Array()  （不常用，了解即可）
new Array(1, 2, 3, 4); // 保存了4个数据
new Array(5); // 没有数据，但是数组默认长度为5，没意义
```



#### 函数:function

> 封装一段代码，让代码可以重复调用，增加使用效率
>
> 只有调用了函数，函数中的代码才会执行。

```javascript
// 声明函数
var 函数名 = function(参数){
 	函数体
}

// 命名函数
var 函数名 = function () {
    // 函数体
};

// 匿名函数
function (参数){
  //函数体
}
// 在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用：
    var fn = function(a,b){
      return a + b;
 }

// 自调用函数
(function () {
   //函数体 
})();
// 定义之后，立刻调用
// 强调：自调用函数后的分号必须加
```



#### 对象：object

> 对象是一种复杂类型的数据形式。

- 对象是由一个或多个**属性**组成的
- 每个属性由**属性名**和**属性值**组成

```js
var obj = { name:'jack'};

//称为'键值对'， 键表示属性名，值表示属性值，对表示属性名和属性值是一对。

- - var obj = new Object(); // 空的对象
```



### 数组和对象的选取方式

- **数组**：数据格式大多数一样

  - 如果要存储多个数据，**数据的含义相同**，使用数组。

- **对象：** 数据格式多样话，且数据类型不统一

  - 如果要存储多个数据，**数据的含义不同**，使用对象.

  

### 基本数据和复杂类型的区别

- 保存数据的个数不同 
  - 基本类型：只能表示一个值
  - 复杂类型：可以同时存储多个数据
- 在内存中的存储方式不同 ( **记忆** )
  - js中操作的数据都属于**临时数据** ，临时数据都在内存中保存
    - 代码不在浏览器中运行，那么就是一堆字，没有实际意义
    - **基本类型在内存单元中存储的是 具体值**
    - **复杂类型在内存单元中存储的是具体值得地址 ( 引用 )**
- 进行复制操作时结果不同
  - 赋值操作实际上是复制内存单元中的值
  - 基本类型复制前后，两个数据没关系
  - 复杂类型复制前后，**两个数据实际上就是同一个**
    - 不同通过赋值操作复制复杂类型数据，复制不到数据



# 数据类型进行比较的特点

> == === != !==

- **复杂类型进行比较操作时，**
  - **只能在两个对象是同一个时，才会返回true**，**否则一定是false** 
  - **两个复杂类型就算长得一样，也只能是false**

```js
/ 长得一样的两个复杂类型值，==和===均返回false
        /* var arr1 = [1, 2, 3];
        var arr3 = [1, 2, 3];
        console.log(arr1 == arr3); // false
        console.log(arr1 === arr3); // false */
        

        // 两个复杂类型必须是同一个时，==和===才能返回true
        /* var arr1 = [1, 2, 3];
        var arr3 = arr1;

        console.log(arr1 == arr3);
        console.log(arr1 === arr3); */
        
        var obj1 = {name : 'jack'};
        var obj2 = obj1;
        console.log(obj1 === obj2);
        console.log(obj1 == obj2);

```







## 数据类型的相互转换

> 数据类型转换有两种方法：**强制转换**，**隐式转换**

### 其他类型转成数值

#### Number: 

 `把要转换的数据在Numenber后面用() 包裹起来`

```js
var res1 = Number('123') // 此时res1 的数据格式变为 数值类型

// 此方法 转换成数值类型有两种结果:
// 成功 number数值 /失败 NaN  == not a number表示某个结果不是一个数字
```



#### parselnt() ：

> 将字符串转换成 **整数**

```js
var res1 = parseInt('123') // 输出为123
// 如果保存的数据前面是 非数字(NaN) 那么会保存，要是后面有 那么会给省略掉
```



#### parseFloat

> 将字符串转换成**小数** ( **保留两位小数** )

```js
var res1 = parseInt('123.123');   // 默认保存两个参数
console.log(typeof res1); // 输出number
```



#### 隐式转换

> 字符串 减去 数值 字符串会隐式转换成数值数据，但是 字符串 转换不了完整数字，就会变成NaN 那就不能相见

```js
var res3 = '456' - 123; 
console.log(res3); // 输出 数字 333
var res4 = 'abc' - 123;
console.log(res4); // 输出NaN 
```



### 其它类型转换成字符串

> 将其他数据类型转换成 **字符串格式的数据**

#### String()

```js
var res1 = String(123);
console.log(res1);  // 输出字符串的 123
console.log(typeof res1); // 输出 string
```



#### .toString() 常用

> 强制转换所有数据成 字符串格式 （**null和undefined除外**）

```js
var res1 = (123).toString();
console.log(res1); // 输出字符串123
console.log(typeof res1); // 输出string
```



#### 隐式转换

> 当一个字符串 数据 和一个 数值数据相加 数值会变成字符串格式，这是 **隐式转换**

```js
// 字符串 + 数字
var res4 = "abc" + 123;
console.log(res4);// 输出 abc123
```



### 其他数据转成布尔值

> 把js代码转换成 **布尔型数据** ， 在js 中 **只有6种情况会把数据转换 false**

```js
var res1 = Boolean(0);
console.log(res1); //输出false
var res2 = Boolean('');
console.log(res2); //输出false
var res3 = Boolean(NaN);
console.log(res3); //输出false
var res4 = Boolean(undefined);
console.log(res4); //输出false
var res5 = Boolean(null);
console.log(res5); //输出false
var res6 = Boolean(false);
console.log(res6); //输出false
```



# 操作符

### 自增/自减操作符

> 字符串相加 会变成 拼接

```js
// ++ --  ==》 自增  自减少
```

**自增/自减操作符书写位置带来不同的区别**

- 在前面

```js
 a++/a--;  参与运算的时候，会先用原来的值先运算，再自增
```

- 后面

```js
 ++a/--a 参与运算的时候，会先在原来的基础上自增，再使用新的值参与运算
```



### 比较操作符

> 数据进行比较 **返回的是布尔值**

```js
// 简单的
>  <  >=  <=
    
// 全等/全不等 的区别 (重点)
== 	 != 
会比较两个数据的值，不会比较数据的类型

===  !==   
仅比较两个数据的值，还比较数据的类型
```



### 逻辑运算符

>  主要作用是连接多个条件

```js
&&  ||  ！
***************************************************************
&& 用在需要多个条件同时成立的时候:
var userName = prompt('请输入用户名');
var password = prompt('请输出密码');
console.log(userName === 'admin' && password === '123456');
// 只有 && 两边的 结果都是 true ，最终结果才是 true
***************************************************************
|| 用在只需要任意条件成立的时候
var age = parseInt(prompt('请输入你的年龄'));
var height = parseFloat(prompt('请输入你的身高'));
console.log(age < 5 || height < 120);
// 只要 || 两边的结果有一个是true，最终结果就是true
***************************************************************
! 用于颠倒是非的时候
console.log(!res); // 不等于 res 
```



### 赋值操作符

> 两大类：赋值   简写

- `=`   的作用就是把右边的结果赋值(存储)给左边的变量之类的容器

```js
var a = 10 + 10; //把　１０＋１０的结果存储到　ａ　这个变量里面
```

- **+=  -=  *=  /=  %=** 作用是简写加法

```js
var a = 10;
a += 2; // 相当于是 a = a + 2; 就是一个简写的语法
console.log(a); // 输出12
```



### 操作的优先级

```js
1. 第一优先级： [] . ()
2. 第二优先级： ++ -- !
3. 第三优先级： *  /  %
4. 第四优先级： +  -
5. 第五优先级： >   >=   <   <=
6. 第六优先级： ==   !=    ===    !==  
7. 第七优先级： &&
8. 第八优先级： || 
9. 第九优先级： = += -= *= /= %=  
```



## 分支结构

> 根据不同的情况，执行对应代码，**其作用就是用来判断的**

### if结构

`if语句 3种写法：	`

#### if 判断

> 单个if结构，解决的一个分支的判断问题

```js
if(条件表达式){
   当条件表达式的结果是 true 时执行的代码
}
```



#### if-esle判断

> if-else结构，解决两个分支的判断问题

```js
if(条件表达式){
   当条件表达式的结果是 true 时执行的代码
}else {
  当条件表达式的结果是 false 时执行的代码
}
```



#### if-else-if判断

> 可以一直持续判断下去
> **if更适用于范围的判断操作**

```js
if(条件表达式1){
   当条件表达式1的结果是 true 时执行的代码
}else if(条件表达式2){
  当条件表达式2的结果是 true 时执行的代码
}else if(条件表达式3){
  当条件表达式3的结果是 true 时执行的代码
}
// 中间可以继续写多个判断
else {
  多个条件表达式的结果都是 false 的时候执行的代码
}
// 每个条件表达式 输出的结果 都是独立出来的部分
```



### switch语句

> 依照固有的值 进行判断
>
> switch更适用于单个值的判断操作（因为默认为全等比较方式，严谨）

```javascript
switch (数据) {
    case 值1：
    	// 代码区域1
    	break;
    case 值2：
    	// 代码区域2
    	break;
    case 值3：
    	// 代码区域3
    	break;
    default: 
        // 代码区域
        break;
}

// 规则:
	- 小括号中的数据会按照从上往下的顺序跟每个case后的值进行全等比较 ===
    - 如果比较结果为true，执行case后的代码区域
	- 代码执行完毕，后续的break表示结束switch执行
	- 如果每个case都不满足，最后执行default的代码
```



## 循环变结构

### for循环

> 按照条件进行 数据遍历(**可嵌套使用，不能不多于2层)** ,多**用在确定次数的 重复操作**

```javascript
for(循环变量声明;循环条件;循环变量的增减){
    // 循环体：循环的主题代码
}

1.循环变量声明: 声明一个与循环有关的变量，用来进行次数控制 
2.循环条件:控制循环变量的变化范围   i<arr.length;
3.循环变量的增减: 根据前面设置的两个值，让循环变量修改，最中可以结束即可  i++
4.循环体中的代码: 重复执行的代码区域
//执行的顺序
 - 步骤1:循环变量声明    var i = 0;
 - 步骤2:循环条件   i<arr.length;
 - 步骤4:执行一次循环体重的代码 
 - 步骤3:修改循环变量
 // 简：243 243 243
```



### while 循环

> **适用不确定次数的重复操作**，

- 特性：先判断在执行代码

```js
- 每次操作前先检测条件，如果最终为 true， 那么就执行一次循环体
- 代码执行完之后，会再次判断 判断为true 那就在次执行代码
- 当条件为 false是，循环结束
  
	while(判断条件){
      // 循环的代码
   }
// 尝试获取用户的输入
var value = prompt('请求输入密码,如995121','慢慢想')

// 密码检测是否正确 
   - 如果输入错误要求重新输入
 while(value !== '123456'){  // 当 条件成立时 执行循环体中的代码
    // 提示
    // alert('请重新输入，账号或者密码错误')
     value = prompt('清输入密码')
 }
// 当条件为false 代码结束
alert('密码正确')
```



### do..while循环

> 循环体中的内容  在进行判断 while 的 结构改进优化

- do..while用来对while进行结构改进时使用，它是 while的 结构改进时使用
  - do..while至少会执行一次

```js
do{
 // 循环体
}while(条件)

// 开始时会先执行一次循环体中的代码
// 代码完毕后检索条件,条件为true，再次执行, 条件为 false，结束执行
```



### 循环结束

> 在循环中使用，打断原有的代码执行规则

#### breack

- 在循环中使用，表示结束循环执行（跳出/结束本次循环）

```javascript
    // 例如：设置执行10次的循环吃包子，吃到第三个后结束
    for (var i = 1; i <= 10; i++) {
        console.log('各种吃包子');
        // 检测，如果吃到第三个，就结束了
        if (i === 3) {
             alert('不好意思，吃饱了，后面的不吃了');
             break; // 表示跳出、结束循环执行
           }
    } 

```



#### continue

- 在循环中使用，表示结束本次循环，并从下一次开始

```js
    // 例如：设置执行10次的循环吃包子，
    //  - 吃到第三个发现有虫子，这个包子就不吃了，接着吃下一个
    for (var i = 1; i <= 10; i++) {
        if (i === 3) {
            console.log('第三个包子有虫子，不吃了');
            continue; // 跳过本次循环 从下一次开始继续
        }
        console.log('各种吃包子');
    }
```



# 作用域

> 作用域指的是js中标识符（变量名、函数名）的生效范围。

`如果是赋值操作，隐式声明全局变量`

- **分类：**

  - **全局作用域**
    - 只要不在函数内部，都称为全局作用域
  - **局部作用域**
    - 任意函数内部都称为局部作用域

  

  - **全局变量和函数**
    - 指的是声明在全局作用域中的变量、函数
    - 访问范围：可以在任意位置访问
  - **局部变量和函数**
    - 指的是声明在局部作用域中的变量、函数
    - 访问范围：可以在当前作用域内部访问
      - 可以是纯内部，也可以是内部的内部，也可以是内部的内部的...内部的内部，也行。





## 作用域链

> 作用域链：指的是**作用域间**的标识符访问规则。

**规则：**

- 当在**任意作用域下**进行变量访问时，会进行以下检测：
  1. 首先查找当前作用域，如果存在就使用
  2. **如果不存在，查找父作用域，如果存在就使用**
  3. **如果不存在，以此类推，最终找到全局作用域**
     - **如果全局作用域中还是不存在**
       - 如果是取值操作，报错
       - **如果是赋值操作，隐式声明全局变量**



## 预解析

> 预解析是js代码执行前的一种**提前对代码的解析**操作

**预解析的操作：**
1 **变量提升：**找到当前作用域中的变量声明var部分，将声明提升到作用域顶端
2 **函数提升：**找到当前作用域中的函数声明语句，将函数体提升到作用域顶端

- **由于函数提升，**函数声明语句可以在书写位置前后进行调用（但是不推荐）
   但是函数表达式不能进行调用操作
- **每个作用域中的预解析都是独立**





# 内置对象API

> js中自带了很多的功能用来方便开发者进行操作，功能有很多
>
> 为了区分不同的功能，将操作相同数据的功能统一的保存在某个对象中，形成了内置对象结构
>
> 只要掌握  **使用方式**



## Math 数学对象

> Math对象是js中的   **内置对象**  ，提供了很多的数学操作功能

```javascript
Math.max()   // 获取最大值
Math.min()   // 获取最小值
Math.ceil()  // 向上取整 (需要掌握)
Math.floor() // 向下取整(需要掌握)
Math.round() // 四舍五入
Math.abs()   // 取绝对值

Math.random( )  //回去随机数(常用)
// 配合使用:随机整数
parsent(Math.random() )
```





## Date 日期对象

`Date 对象是js中用来进行日期操作的一种对象 如果没有指定时间格式，它就是一串数字`

- 操作方式
  - **创建方式:**

```javascript
var data = new Date() // 默认为当前的计算机时间

// 也可以按照指定操作获取想要的信息
var date = new Date();
    console.log(date.getFullYear()); // 获取年
    console.log(date.getMonth()); // 获取月份，从0开始，使用时记得+1
    console.log(date.getDate()); // 获取日
    console.log(date.getDay()); // 获取星期，周日取值为0
    console.log(date.getHours()); // 获取小时
    console.log(date.getMinutes()); // 获取分钟
	console.log(date.getSeconds()); // 获取秒
	console.log(date.getMilliseconds()); // 获取毫秒，1秒=1000毫秒 
	
// 当想把时间当成数据传输的时候，都会把变成 毫秒
    console.log(date.getTime()); // 推荐
    console.log(+date); // 也凑合
    console.log(Date.now());
    console.log(date.valueOf());
    console.log(Date.parse('2015-1-1'));
```





# 三元运算符

> if  else 的简写方法，让代码更加简洁，书写方式也比较简单

- **条件 ? 结果 (true)：结果(false)**
  - 当条件执行完之后，正确就为第一条数据
  - 失败就是第二条数据

```js
flag ? $('body').addClass('hover') : $('body').removeClass('hover') 

// 如果 flag 为真 就执行第一条数据
// 否则就执行第二条数据
```



# 逻辑运算符

> 相当于简写 if else属性的一种方法



## 逻辑或  ||

> 判断条件，两个添加只要有一个条件为真，整理就为真   `或者`

- 逻辑或" 首先看左边的值是真还是假,
- 如果是真,**返回的是左边的值**,如果是假返回的是右边的值

```js
//  if(1==1 || 2==3){}//->两个条件中只要有一个条件为真,整体就为真 "或者"
```



`只有 0、NaN、null、undefined、空字符串 为假,其余都是真`

`当||和&&同时出现的时候,&&的优先级大于||`

## 逻辑与 &&

> 两个条件中只有条件都为真,整体就为真 `并且`

- 首先看左边的值是真还是假,
- **如果是真**,**返回的是右边的值,**
- **如果是假返回的是左边的值**

```js
//if(1==1 && 2==3){}//->两个条件中只有条件都为真,整体就为真 "并且"
```

