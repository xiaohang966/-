# ##浏览器组成部分

- 内核(渲染引擎)：用来执行html和css，渲染出页面
- JS引擎(独立的渲染引擎)：用来执行javascript代码使用的



### 两种前端

- 普通前端：负责所有用户能看到的基础页面

- web前端，逻辑，页面的完成，页面行为



# #JavaScript基础   

- js代码三步骤：得到值    保存值    使用值
- 它是脚本语言             
  - 拓展：   less   sass  预编译语言
- js一种单线程语言，
- 用户所有输入的内容都是字符串内容，

- EMAScript：简称es，用来规范JavaScript语法，具有多个版本
  - 基础规则
- DOM- 文档对象模型，用来操作页面上的标签
  - WebAPI阶段
- BOM - 浏览器对象模型，用来操作浏览器的部分功能
  - webAPI 内容 



### 变量

- 变量就是存储数据的容器，很多数据操作，进行多次进行数据操作，而且会出错



- 声明变量
  
  - var 变量名
  - var myName
  
  
  
- 变量的赋值
  
  - 变量名=值
  - myName=20
  
  
  
- 声明变量和变量赋值

  - var myName =20

  

- 多个变量同事进行声明或赋值操作：可以混合写

  - var myName ='张三'，myAge , myGender ='男'



### 数据类型

基本类型：

- numbe(数字)，
  - 特殊数值：isNaN=非数值

- boolean(布尔值)
  - true=对=是,false =错=不是
- undefined(未赋值)
  - defined :定义
    - 变量声明没赋值，默认值为undefined
- null(空)：
  - 主动清除变量数据
- string
  - js中用-单引号 ：   '  '
  - HTML+CSS双引号：" "
  - 转意符：\   \
    - 将特殊字符变成普通字符
    - 将普通字符变成特殊字符

变量内容变换

- 实现方法：变量1，变量2  需要 另外一个容器

  ```javascript
  /*变量交换*/
  var str1 = '第一个变量的内容'
  var str2 = '第二个变量的内容'
  
  /*交换变量内容*/
  var temp ='';
  str1 = str2 
  str2 = temp
  temp =str1
  ```

### 检测数据类型

转换数据的类型：

- 第一种：typeof
- 第二种：typeof()



### 数据转换类型

#### string字符串转换：

强制数据类型转换：

​	null，undefiend，不可以 因为没有

```javascript
console.log( str1.toString())
```



 把数据输出成字符串数据：任何数据类型都可以

```javascript
console.log(String(数据))
```



隐式转换

- 字符串和任意类型进行+ 操作，最懂结果都是字符串
- 通常类型转换时使用空字符串( " " )进行操作

```
console.log( " " +200 )
输出类型：字符串
```



#### Number数值转换

普通用在字符值转数值上

- 普通数据转换：

```javascript
console.log( Number('100') )
/*正常输出*/

/*非数字值的转换*/
console.log( Numeber('abc') )
输出为NaN,为数字
```

- parseInt和parseFloat都是用来字符串的操作，其他不行
  - 字符串使用：parseInt() --- 数值取整
    - 可以把字符串中的数值取出来
    - 从左侧往右查找，取出整数的部分
  - 字符值使用：parseFloat() ---数值取整(含小数)



- 隐式转换
  - 正负号：只有数值有的概念 : console.log(+'100')
    - 但只要包含任何非数值：那就NaN

# #运算符(操作符)

**算数运输符**：

- 小数的精度计算：避免小数的加减计算



**一元运算符：**

- 操作运算的就有一个值
- 正号+  负号—   typeof



**自增自减法:**

- 让变量里面的值增加或者减少 1
  - 必须是变量里面的值  
  - 有几个 就加几回



**比较运算:**

> 统一特点：比较运算符根据式子的真假返回boolen

- 相等运算符：比较值得类型 再是大小    
  - == 相等  ----     !=   不相等(不严谨)
  - ===完全相等  ----  !== 完全不相等(推荐使用，严谨)
- 特殊NaN：正比  都是false  
  - NaN 数值 :js 提供检测一个数据是否为非数值
  - isNaN :是非数值   isNaN()     不是数值 是true   |  是数值 false



**逻辑运算符:**

- 逻辑与&&(逻辑且)

  - 写法： 操作数1 && 操作数2  
    - 两个操作数均为true,返回true，任意一个为false，结果为false

- 逻辑或运算符

  - 写法： 操作数1 || 操作数2
    -   两个操作数均为true,返回true，任意一个为true，结果为true

- 逻辑非运算符

  - 写法 ！： 作用用来取值得反意思

  

**其他使用方式：**

- 规则：(当某个操作数为非布尔值时)

  - 从左往右看
  - 如果不是布尔值，会隐式转换
  - 当前操作数如果决定了式子的结果，直接返回原值
    - 当前操作数无法决定时，返回另一个操作数

  结果是操作数的原值，不是转换后的布尔值

**赋值运算符:**:

- num += 10   :    num= num+10



 **三元运算符:**

> 格式：条件操作数? 操作数1：操作数2



**运算符的优先级:**

- 优先级从高到低为：
  - 小括号：  (  )
  - 一元运算符：正+负-号 ， ++-- ，typeof
  - 算数运算符：
  - 比较运算符
  - 逻辑运算符
  - 三元运算符
  - 赋值运算符 

##浏览器中输出的方式

- 弹出提示框

```javascript
alert('hello world')
```

- 输入提示框:用户输入框

```javascript
prompt('请输入内容','请输入姓名')
/*两个参数*/
-第一个提示内容
-第二个输入框默认值设置
```

- 让内容在浏览器控制台输出

```javascript
/*可以同时输出多个内容*/
console.log('内容1')

/*升级版：详细输出内容*/
console.dir('内容1')
```



- 确认提示框

```javascript
confirm('上课让我快乐')
```

- 页面文档输入

```javascript
document('这是文档内容')
/*正常文本除外，里面还可以生成页面标签结构*/
docunment.write('正常文档')
docunment.write('<div>这是DIV标签</div>')
```



# #程序的流程控制

**分类:**

- 顺序结构：是程序的默认结构，特点是从上往下一行一行执行
- 分支结构
  - 根据某些条件，选择某些代码执行或不执行
- 循环结构
  - 用来重复执行某段代码，简化操作



### 分支结构

####  if语句：

格式：

- 单分支（单if）

- ```javascript
  if (条件) { // 条件需要为布尔类型，非布尔值会隐式转换
      // {}中的范围称为代码块，用来表示if的作用范围
      // 只有条件为true时，代码才会执行
  }
  ```

- 双分支 (if.. else)

- ```javascript
  if (条件) {
     // 如果条件为true，执行if的代码块
  } else {
     // 如果条件为false，执行else的代码块
  }
  ```

- 多分支（if.. else if..else if.. else）

- ```javascript
  if (条件1) {
      // 条件1为true，执行当前代码块，后续操作就不执行了
  } else if (条件2) {
      // 条件2位true，执行当前代码块，后续操作也不执行了
  } else if (条件3) {
      // 同理...
  } else {
      // 前面的所有添加都不满足时，最终执行else代码块
      // 注意：else可选
  }
  
  // 上面的示例中 else if的个数可以自己设置，多少个都行
  ```



#### switch语句:

- 语法形式：

```javascript
switch(数据|变量名字){
 case 值：1
   //代码区域
    break;
 case 值：2
   //代码区域
   break;
 case 值：3
   //代码区域
   break;
 default:
   //代码区域
   break
}
//规则:
- 小括号中的数据会按照从上往下的顺序跟每个case后的值进行全等比较 ===
- 如果比较结果为true，执行case后的代码区域
- 代码执行完毕，后的break表示结束switch执行
- 如果每个case都不满足，最后执行default的代码
```



#### if和switch语句的区别:

- switch更使用于当个值得判断操作（因为默认认为全等比较方式，严谨）
- if 更使用于范围的判断操作



### 循环结构

#### for循环

- 语法结构：

```javascript
//循环变量的声明：var 1=0；
//循环变量声明：声明一个与循环有关的变量，用来进行次数控制

//循环条件：i<10;
//循环条件：控制循环变量的变化范围

//循环变量的增减：i++
//循环变量增加;根据前面设置的两个值，让循环变量寻该，最终可以结束即可
//执行顺序；
//例子：
for(var i= 0;i<10; i++){
    //循环体代码：重复执行的代码区域
    console.log('好人')
}
```



#### while循环

- 语法

```javascript
规则：
	- 每次操作前先检测条件，如果最终结果为true，执行一次循环体
	- 会再次检测条件，一次类推
 	- 当条件为false，循环结束
while(条件){
    //执行代码
}
```



#### do..while循环

- 语法

```javascript
do{
  //循环体
}while(条件){
 // 规则：
   开始时先执行一次循环体代码
   执行完毕后检测条件，条件为true，再次执行，条件为false，结束执行
}
```

与while的区别：

- do..while 可以改进while循环的代码
  - do..while是最少执行一次在判断
  - 它是while 的改进写法

#### for和while的区别：

- **for循环使用于次数确定的重复操作**
- while循环使用于次数不确定的重复操作
  - 示例：要求用户输入密码，密码不正确，再次输入，直到正确为止
    - while(value !== '密码){
    - 执行代码}



#### break和continue

>是在循环中使用的两个功能

- break
  - 在循环中使用，表示结束循环执行(跳出循环)
- continue
  - 在循环中使用，表示结束本次循环，并从下一次开始



**表达式和语句(了解):**

- 表达式
  - 是程序的最小的组成部分。
  - 概念：**有结果的式子都可以称为表达式**
  - 常见的表示式有：
    - 数据 100 ‘abc’ false undefined null
    - 任意的计算操作的结果也称为表达式
- 语句：
  - 程序是有多个语句组成的，一个语句是有多个表达式组成的。
  - 概念:代码结尾有 ; 的代码都是一个语句
    - if语句，seitch语句，for循环语句，while循环语句，do..while循环语句



### 复杂数据类型：

#### #arrgy:数组

> Array :  数组：可以保存多个数据，这些数据称为数组的元素

浏览器：展示数据是，当对复杂数据在控制台中'展开' ，显示的是最新的值

声明方式:

- var arr =[1,2,3,4,5]

- > var arr = new Array(3)  //单个值：表示数组内容的长度 

数组常用方法：

- arr.length: length属性的值为数值类型，表示元素个数

  - 如果修改length的值，数组的元素个数会随之改变；

- arr.length = 3 ； 

  - 可以将length设置为更少的值，后续的多余元素会被删除

  - 不要将length的值设置的比实际元素的个数多，没有意义

    清空数组：数组.length = 0; 

    

- 数组的索引(下标)：
  - 概念：数组中的元素按照索引排列，编程中的索引是从 0 开始的，自动自增
  - 数组[索引值]：获取该索引值下的数据；
  - 数组[索引值] = 数据； 修改数组中 该索引下的值 ；
  - 数组的遍历操作

  ```javascript
  // 普通遍历
  //数组中的元素索引是有规律的，可以用for循环得到
  // 设置遍历时，i 的范围设置为 <数组.length即可
  for(var i = 0; i<arr.length;i++){
    console.log(arr[i])
  }
  
  //数组的反向遍历
  //  arr.length - 1 表示数组元素的最大索引值
   for(var i =arr.length-1 ;i>=0; i--){
     console.log(arr[i])
   }
  ```

  

- 给数组添加元素方式
  - 因为数组的索引值和数组的长度是相同的 所以增加数组元素可以增加数组的元素
  - 只能在数组元素后面增加新的元素

  ```javascript
  var arr = [a,b,c]
  arr[arr.length] = 'z'
  arr[arr.length] = 'd'
  arr[arr.length] = 'z'
  console.log(arr)
  ```

#### object：对象

> 对象是一种复杂类型的数据形式

- 对象：
  - 独享是由一个或多个**属性**组成的
  - 每个属性由**属性名**和**属性值**组成的
- 对象的声明方式：
  - var obj = {}
    - 好处：写法简单，可以在声明时直接设置属性
    - 这种写法可以称为’**键值对**‘ 
      - 键：表示属性名
      - 值：表示属性值，
      - 对：表示属性名和属性值是一对的
  - varobj = new object() //创建的空的对象

##### #对象的属性操作

- 除了基本声明时的属性操作外，还可以再后期单独进行属性操作

```javascript
var obj = {
    name : 'jack'
};

// 第一种操作形式：
console.log( obj.name ); // 访问obj的name属性值
obj.name = 'rose'; // 设置obj的name属性值
obj.age = 18; // 给obj设置新的属性age，值为18

// 第二种操作形式：
console.log( obj['name'] ); //  访问obj的name属性值，相当于obj.name
obj['name'] = 'rose';
obj['age'] = 18;
```

##### #对象的属性和方法

> 方法其实也是属性，方法指的是保存了函数值的属性。
>
> ​	因为函数的使用方式是调用，其他数据都没有调用操作，为了方便区分，所以起了个不同的名字

- 方法可以是命名函数也可以是匿名函数
  - 如果多个对象的方法一样，使用命名函数统一保存
    - 将命名函数设置给方法时，一定不要加()
- 如果当前方法只有一个，使用匿名函数保存即可

```javascript
		function sayHi2 () {
            console.log('呵呵呵, 您吃了没~');
            return 200; 
        }

        var obj = {
            name : 'jack',
            // 将命名函数设置为方法时，不要写()
            // sayHi : sayHi2()
            sayHi : sayHi2,
            coding : function () {
                console.log('因为我是程序猿，每天的工作就是各种打代码');
            }
        };
        

        var obj2 = {
            name : 'rose',
            // 方法需要的是函数体，不需要在当前位置调用
            sayHi : sayHi2,
            zhiBing : function () {
                console.log('各种治病，治各种病');
            }
        };

        console.log(obj, obj2)
```

##### #对象和数组的区别

- 对象 object
  - var 对象名 = { 花括号  name=值}  值得类型的叫做键值对
- 数组 array
  - var 对象名 = [下标] 



##### #对象的遍历

- 对象属性按照属性名保存，属性名无序，所以称对象是无序的数据存储方式。
- 数组元素按照索引排列，索引是有序的，所以称数组是有序的数据存储方式。



**对象遍历：使用for..in遍历对象**

```javascript
  var obj = {
            name : 'jack',
            age : 18,
            gender : '男'
        }
        // for (var 循环变量 in 要遍历的对象) {}
        for (var key in obj) {
            // key代表属性名，字符串类型，每次循环自动获取到一个不重复的属性名
            // console.log(key); 'name' 'age'  'gender'

            // obj[key]代表属性值
            console.log(obj[key]);
        }

```




### 基本类型和复杂类型的区别3个

- 保存数据的个数不同
  - 基本类型值都只能表示一个值
  - 复杂类型可以同时存储多个数据
- 在内存中的存储方式不同（需要记忆）
  - js语法中我们操作的数据都属于临时数据，临时数据都在内存中保存
    - 如果不在浏览器中运行，代码就是一堆字，没有实际意义
    - **基本类型在内存单元中存储的是具体值**
    - **复杂类型在内存单元中存储的是具体值的地址(指针、引用)**
- 进行复制操作时结果不同
  - 赋值操作实际上是复制内存单元中的值
  - 基本类型复制前后，两个数据没关系
  - 复杂类型复制前后，两个数据实际上就是同一个
    - 注意：不能通过赋值操作复制复杂类型，达不到目的
    - 回去思考，怎么能真正的复制一个数组呢？ 例如  var arr = [1, 2, 3];

###冒泡排序

- 让数组有序的排列

```javascript
        // 设置一个需要进行排序的数组
        var arr = [13, 21, 24, 52, 12, 66, 18];

        // 冒泡排序的实现：按照分析的规律进行操作即可
        //  - 外层循环控制轮数
        for (var i = 0; i < arr.length - 1; i++) {
            // - 内层循环控制每轮的比较次数
            //    - 规律中j循环的条件为比i多1，设置时需要多减1
            for (var j = 0; j < arr.length - i - 1; j++) {
                // 比较当前元素和后面元素的大小
                //  - 后面的元素的索引肯定比当前元素索引大1
                //    - arr[j]表示当前元素时，arr[j + 1]就是后项
                //      - * 如果希望从大到小排序，修改>为<即可
                if (arr[j] > arr[j + 1]) {
                    // 交换两个位置的值
                    var temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        console.log(arr);
```



### #数组去重

- 数组重复内容筛选出去
  - 创建一个新的数组，把另外一个数组中不重复的元素，保存到新的数组中

```javascript
        var arr = [1, 1, 1, 2, 3, 3, 1, 4, 2, 6, 4, 6, 7, 5, 12, 21, 12];
        // 1 声明一个新的数组用来保存结果
        var result = [];

        // 2 尝试将数组arr中的元素放入到result中，但是result中的元素不能重复
        //   - 遍历arr获取元素
        for (var i = 0; i < arr.length; i++) {
            // 3 先确定arr[i]在result中是否存在
            //    - 需要用arr[i]和result中的每个元素进行比较
            //    - 对result进行遍历操作
            var flag = '默认没有和arr[i]相同的值';
            for (var j = 0; j < result.length; j++) {
                // 比较arr[i]和result[j]是否相同
                if (arr[i] === result[j]) {
                    // 更改flag的值
                    flag = '找到了相同的值';
                    // 设置break结束，只是为了提高执行效率
                    break;
                }
            }
            // 全部比较完毕后，检测是否找到了相同的值
            if (flag === '默认没有和arr[i]相同的值') {
                // 将arr[i]放入到result中即可
                result[result.length] = arr[i];
            }
        }
        console.log(result);
    
```



## #函数

- 让代码灵活性高，可重复用

- 什么是函数：

  - 函数就是一个可重复使用的代码块

- 声明方式：

  - 函数声明语句

  - ```javascript
    function 函数名(){
       //函数体
    }
    ```

  - 函数表达式

  - ```javascript
    var 函数名 = function(){
    	//函数体
    }
    ```

- 函数的调用方式：

  - 概念:函数不调用就不会执行，任意需要的位置进行调用，表示在调用位置执行函数内的代码。
  - 普通函数调用格式： 函数名()



- 函数的参数；

  - 函数类型：
  - 形参：函数体小括号中的参数，多个参数使用逗号分隔。	
    - 用来给实参占位置，会在调用后接受实参值进行操作
  - 实参：调用小括号中的参数，多个参数使用逗号分隔
    - 用来给形参设置实际值使用

  

- 函数的返回值

  - 含义：函数的返回值值得是函数的结果
  - 作用：让函数内的计算结果可以被外界操作
    - 函数中的变量无法在函数外使用
  - 格式：
    - return 值
  - 接受方式：
    - 通过函数的调用表达方式接受；
      - var 变量 =函数名() // 变量结果就是返回值
      - console.log(函数名) //调用表达式本身也代表返回值，不保存也可以使用
  - 函数返回值:
    -  如果函数调用后，希望获取到函数的计算结果，需要给函数设置返回值   
    -  接收方式：通过函数的调用表达式来接收结果。
  - 函数结束方法：
    - return是function中的结束执行的代码
    - for循环中使用break    continue



- **arguments:**

  - > 如果设置的实参个数不确定，正常通过形参无法接受，可以使用 arguments
    >
    > 在函数中使用表示本次调用中的所有的实参

  - arguments 像是数组  但不是真正的数组，它是伪数组或者叫做 类数组

    - 但它具有索引和长度，但是不能使用数组的一些特殊方法



- **对象的属性删除：**delete

  > delete  对象名.属性名字

  - 删除对象的属性



- **构造函数**：同时创建多个对象的方法，

  - 方法1：通过函数进行多个对象的创建(工厂模式 不常用)

  ```javascript
  function ceeateObj(name,age,gender){
    var obj ={
     name:name,
     age:age,
     gender:gender,
    }
    return obj;
  }
  
  var obj1 = createObj('jack',18,'男')；
  var obj1 = createObj('rose',21,'女')；
  console.log(obj1,obj2);
  ```

  
  - 方式2：通过构造函数进行多个对象的创建(常用)
    - 注意：调用构造函数 **必须加 new**
    - new 创建了一个对象 ，还返回了这个对象
    - new 给函数内设置了一个特殊的表示符 **this**
      - this的值就是new创建的对象
    - 函数调用时前面+new 可以直接调用  ： new 函数  不用写（）  【基本不用】
  - 建议：构造函数命名首字母大写： 首字母大写的字母基本都是构造函数的方法
  - 大写小写不会让功能产生影响，主要是方便分辨 普通函数：首字母小写  构造函数：首字大写

  ```javascript
  //常规写法
  function createObj(){
     //通过this 增加的属性
     this.name = name,
     this.age =age,
     this.gender =gender
     this.sayHi = function() {
         console.log('我是方法')
     }
  }
  var obj1 = new createOBJ('jack',98,'男')
  var obj2 = new createOBJ('rose',100,'女')
  console.log(obj1,obj2);
  obj.sayhi()
  
  ```

  

### #匿名函数:自调用函数

- 命名函数和匿名函数：
  - 命名函数：有名字的函数
  - 匿名函数：没有名字的函数 (匿名函数必须在结束时加分号，否则匿名函数执行时会报错)不能单独使用，因为没有名字
  - 效果：在书写的位置执行一次
    - 减少全局变量的使用
    - 如果所有变量都是全局的，查找变量会减慢，
    - 还能防止变量名字污染

```javascript
//语法格式：立即自己执行
 (function (){
     //局部作用域
     console.log('我是匿名函数')
 })
```



### #回调函数：

>含义：指得是某个函数，作为其他函数的参数为使用

- 注意：回调函数使用命名函数和匿名函数均可，没有区别
  - 使用匿名作为参数时 ，只能使用一次  调用就可以直接 把函数名字填写进去就可以
  - 命名函数：可以重复执行



## #数据检测类型方法

- 通过typeo检测
  - 类型名：'function'
  - 格式：typeof 函数名；
    - 检测函数时不要加 ( ) ,否则便是调用函数 ，并对返回值进行类型检测



- 如何对复杂类型进行类型检测

  - typeof 检测数组和对象都返回 'object'，达不到检测的目的

  - instanceof 操作符

    - 格式:   操作数 instanceof 构造函数名
    - 返回值：布尔类型

  - constructor  （主要记忆这个）

    - 格式： 数据.constructor

    - 返回值：创建当前数据的构造函数

    - 实际使用时，需要将结果和某个构造函数进行比较

    - ```javascript
      var arr = [1, 2, 3];
      console.log( arr.constructor === Array ); // true
      console.log( arr.constructor === Object ); // false
      ```

  - （了解方式，慢慢记）

    - Object.prototype.toString.call(数据);

      - 类型名的格式：   '[object 首字母大写的类型名称]'

      ```javascript
      console.log(Object.prototype.toString.call('abc')); // '[object String]'
      console.log(Object.prototype.toString.call({name : 'jack'})); // '[object Object]'
      console.log(Object.prototype.toString.call(null)); // '[object Null]'
      ```

- null的typeof检测不准确的问题（了解）

  - typeof检测null结果是'object'，是因为检测不准确
  - null就是基本类型
    - 原因：typeof检测内存单元中是否为地址，null保存的就是一个空地址，所以被typeof认为是复杂类型。



### #递归

> 一个函数在当前格式中，调用自己的函数的参数

- 形式：递归最容易出现的问题 '代码死循环'

  - 解决方式：记得给递归设置合理的结束条件即可

    - 设置变量计数，假如运行10次就停止

    

## #作用域

>作用域是指js中 的生效范围 。标识符(变量名，函数名)的生效范围。

- 分类：
  - 全局作用域
    - 只要不在函数内部，都称为全局作用域
    - 全局在正常情况下访问不到function中的声明变量
    - return之后就可以访问到
  - 局部作用域
    - 任意函数内部都称为局部作用域
    - 局部可以访问全局声明好的变量
  - 全局变量和函数
    - 指的是声明在全局作用域中的变量，函数
    - 访问范围:可以在任意位置访问
  - 局部变量和函数
    - 指的是声明在局部作用域中的变量，函数
    - 访问范围：可以在当前作用域内部访问
      - 可以是纯内部，可以是内部的内部，也可以内部的内部的内部，都可以



**变量的多种声明方式对作用域的影响**

- 不规范的操作
  - 没加var，直接进行变量的赋值，最终会隐式声明成全局变量
  - var 变量1=var 变量2=var 变量3=数据
    - 其中只有变量是正常的 
      只有变量名1是规范，后面的其他变量都是隐式声明的全局变量
- **简单说**： 在函数中，变量赋值没有声明的话，会被偷偷的变成全局变量，此时函数只要使用了，外部就可以单独访问到这个变量

- **注意**：所有的不规范形式都不要使用



## #作用域链

- > 作用域链：指的是作用域间的标识符访问规则；

  - 首先查找当前作用域，如果存在就使用
  - 如果不存在，查找父作用域，如果存在就使用
  - 如果不存在，以此类推，最终找到全局作用域
  - 如果全局作用域中还是不存在
    - 如果是取值操作，报错
    - 如果是赋值操作，隐式声明全局变量



- - -



## #预解析

> 预解析是js代码执行前的一种**提前对代码的解析**操作

- 预解析的操作：
  1 变量提升：找到当前作用域中的变量声明var部分，将声明提升到作用域顶端
  2 函数提升：找到当前作用域中的函数声明语句，将函数体提升到作用域顶端
  - 由于函数提升，函数声明语句可以在书写位置前后进行调用（但是不推荐）
     但是函数表达式不能进行调用操作
  - 每个作用域中的预解析都是独立



## #根据数据创建结构

> 书写页面中的所有数据都是固定的，需要修改时，需要手动一个个的改，耗时
>
> 根据数据进行结构的创建比手动操作方便而且更快



## #复杂类型进行比较操作的特点

> == === != !==

- 复杂类型进行比较操作时，
  - 只能在两个对象是同一个时，才会返回true，否则一定是false 
  - 两个复杂类型就算长得一样，也只能是false

  ```javascript
		// 长得一样的两个复杂类型值，==和===均返回false
        /* var arr1 = [1, 2, 3];
        var arr3 = [1, 2, 3];
        console.log(arr1 == arr3); // false
        console.log(arr1 === arr3); // false */
  ```


        // 两个复杂类型必须是同一个时，==和===才能返回true
        /* var arr1 = [1, 2, 3];
        var arr3 = arr1;
    
        console.log(arr1 == arr3);
        console.log(arr1 === arr3); */
        
        var obj1 = {name : 'jack'};
        var obj2 = obj1;
        console.log(obj1 === obj2);
        console.log(obj1 == obj2);
  ```javascript
#内置对象API简介

- API
  - API是Application Programming Interface 的缩写，中文：应用程序编程接口
  - 接口：
    - 概念：**能够提供某种能力的事物** 称为接口
  - API 应用程序编程接口
    - 可以提供应用程序编程能力的一种事物，称为API
    - 具体能力形式分为两种
      - 提供我们自己无法实现的功能
      - 让我们操作简化的功能
- 内置对象API
  - js中自带了很多的功能，用来方便开发着进行操作，功能有非常多
  - 为了区分不同功能，将操作相同数据的功能统一的保存在某个对象中，形成了内置对象结构
  - **对于别人提供功能，我们只要掌握使用方式，可以简化开发即可。**

### #Math对象功能

>Math对象是js中的内置对象，提供了很多的数学操作功能  **字体加粗为常用**

- Math.max() : 获取最大值

  - 用来获取传入的所有的参数中的最大值

  ```javascript
  //获取传入的最大值
  console.log(Math.max(1,2,3,789,6,4))
  ```

  

- **Math.min():获取最小值**

  - 用来获取传入的所有的参数中的最小值

  ```javascript
  //获取传入的最小值
  console.log(Math.max(1,2,3,789,6,4))
  ```

  

- **Math.random(): 获取随机数**

  - **随机数范围：[0,1]    含0单不含1** 从低到高 不含值高的数

  ```javascript
  // 可以设置随机整数
  // 获取随机整数
  parseInt(Math.random() * 11)
  
  // 获取数组随机元素
  // 往上取值不包含
  var i = parseInt(Math.random() * arr.length)
  console.log(arr[i])
  ```

  

- **Math.ceil() : 向上取整**

  - **将含小数位的数值   取到比他大的最近的整数**

  ```javascript
  //正整数
  Math.ceil(2.1)  //3
  //负整数
  Math.ceil(-2.1)  //-2
  ```

  

- **Math.floor(): 向下取整**

  - **将含小数位的数值   取到比他小的最近的整数**

  ```javascript
  //正整数
  Math.floor(2.6)  //3
  //负整数
  Math.floor(-8.7)  //-9
  ```

  

- Math.round(): 四舍五入  不常用

  ```javascript
  Math.round(2.4) // 2
  ```

  

- Math.abs():  取绝对值

  ```javascript
  // 数值转正
  Math.abs(-3) // 3
  ```



### #Date 日期对象

> Date ：js中获取时间的对象
>
> 它是一个构造函数，所以需要通过new 创建对象后进行操作

- 创建方式

```javascript
var date = new Date(); // 默认为当前计算机时间
var date = new Date('2015-12-21 18:21:36'); // 推荐写法
 - 如果设置时间时采用数值传入，注意月份从0开始
var date = new Date(2015, 2, 1, 3, 4, 5); // 例如，这个日期为3月份
console.log(date);
```

- 提供的方法(慢慢记) , 获取日期信息的一些方法

```
	Date提供的方法(全都不用硬背)
        var date = new Date();
        console.log(date.getFullYear()); // 获取年
        console.log(date.getMonth()); // 获取月份，从0开始，使用时记得+1
        console.log(date.getDate()); // 获取日
        console.log(date.getDay()); // 获取星期，周日取值为0
        console.log(date.getHours()); // 获取小时
        console.log(date.getMinutes()); // 获取分钟
        console.log(date.getSeconds()); // 获取秒
        console.log(date.getMilliseconds()); // 获取毫秒，1秒=1000毫秒 
```

- 将日期对象转换为毫秒形式

```javascript
		console.log(date.getTime()); // 推荐
        console.log(+date); // 也凑合
        console.log(Date.now());
        console.log(date.valueOf());
        console.log(Date.parse('2015-1-1'));
```

​	

## #内置对象

###  #数组

> 数组Array，使用形式和Date一样，都是构造函数

**基本操作方法4个**

- **push()向数组末尾添加元素**

  - 参数：任意个数
  - 返回值：数组的length

  

- **pop() 从数组的默认后面的位置删除一个元素**
  
  - 返回值：删除的元素



- **unshift() 数组的前面开面增加元素**
  - 参数：任意个数
  - 返回值：数组的length



- **shift 数组的前面删除一个元素**
  - 返回值：删除的元素

```javascript
		// 练习1 将数组的第一个元素移动到数组最后
        var arr = [1, 2, 3, 4, 5];
        arr.push( arr.shift() );
        console.log(arr); */

        // 练习2 将数组的最后一个元素移动到数组的最前
       var arr = [1, 2, 3, 4, 5];
        arr.unshift( arr.pop() );
        console.log(arr); 
```



- **splice() ：可以在数组上任意位置 增删改 (必须掌握)**
  - 参数1：开始操作位置的索引值
  - 参数2：删除的元素的个数
  - 后续参数：会向删除位置添加元素(个数无需对应)
  - 返回值：由删除的水元素组成新的数组        

演示代码：

```javascript
		// - 删除功能: 例如删除bcd 3个元素
		var arr = ['a', 'b', 'c', 'd', 'e'];
        var result = arr.splice(1, 3);
        console.log(arr); // ['a', 'e']
        console.log(result); // ['b', 'c', 'd']

        // - 修改：例如将bc修改为wxyz
        var arr = ['a', 'b', 'c', 'd', 'e'];
        var result = arr.splice(1, 2, 'w', 'x', 'y', 'z');
        console.log(arr); //  ['a', 'w', 'x', 'y', 'z', 'd', 'e'];
        console.log(result); // ['b', 'c']
        
        // - 新增功能：例如在a后面新增xyz
        var arr = ['a', 'b', 'c', 'd', 'e'];
        var result = arr.splice(1, 0, 'x', 'y', 'z');
        console.log(arr); // ['a', 'x', 'y', 'z','b', 'c', 'd', 'e'];
        console.log(result); // []
    
```



- **slice() 拷贝数组中的部分元素**
  
  > 注意：需要和 splice 区分开
  
  - 参数1：开始位置的索引值
  - 参数2：结束位置的索引值(取值不含结束位置)
  - 参数1默认0，参数2默认为length，如果不写，默认从到取到尾
  - 返回值：拷贝的元素组成的新数组(对原始数组没有影响)
  
  ```javascript
  	var arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
          // 例如：复制b和c
          /* var result = arr.slice(1, 3);
          console.log(arr); // ["a", "b", "c", "d", "e"]
          console.log(result); // ["b", "c"] */
      
          // 例如：复制整个数组
          //  - 两个参数都具有默认值，如果都不写，默认从头取到尾
          /* var result = arr.slice();
          console.log(arr, result);
          arr[0] = 200;
          console.log(arr, result); */
  
          // 例如：从b取到数组末尾
          var result = arr.slice(1);
          console.log(result);
  ```
  
  



- **concat() 用于数组连接 - (必须掌握)**

  - 任意个数参数：将参数按书写顺序放入数组末尾
    - 如果参数是数组，放入的是数组内的元素，而不是整体放入
- 返回值：返回连接后的新数组(不会影响原始数组)
  - **concat代码演示**：
  
  ```
		/* var arr = [1, 2, 3];
          var result = arr.concat('a', 'b', ['x', 'y']);
          console.log(arr); // 原数组不会修改
          console.log(result); // [1, 2, 3, 'a', 'b'] */
          
          // concat使用时通常只用于数组连接(只会传入数组形式的参数)
          var arr1 = [1, 2, 3];
          var arr3 = ['a', 'b', 'c'];
          var arr4 = ['x', 'y', 'z'];
          var result = arr1.concat(arr3, arr4);
          console.log(result);
  ```
  
  



- **indexOf() 用于获取某个元素的索引 -(必须掌握)**

  - 参数1：要查找的元素值

  - 参数2：开始查找位置的索引，默认为0

  - 返回值：

    - 返回找到的第一个元素的索引值
    - 如果找不到对应元素，返回-1 (代表没有)

  

  
- **sort()  数组的排序方法 -(必须掌握)**

  - 希望对数组正常排序，需要传入参数
  - 升序参数-(从小到大)

  ```javascript
  - 升序参数（从小到大）：
    - function (a, b) { return a - b; }
  - 降序参数（从大到小）：
    - function (a, b) { return b - a; }
  
  ```

  

- **reverse() 数组排序 - 翻转数组**

  - 效果：调用后，数组的所有元素被翻转

  

- **toString() 将数组转换成字符串**

  - 返回通过逗号，连接的数组元素，返回值为字符串类型

  

- **join()  用于将数组的元素进行连接-并转换成字符串 -(必须掌握)**

  - 参数： 连接符
  - 返回值： 通过制定连接符连接的数组元素，默认为逗号，( 类似toString  )，字符串

  ```
  
  ```





### #字符串

- 字符串是基本属性

- 独享具有属性方法，是复杂类型。

  

- 正常来说字符串这些基本类型应该没有属性和方法

- 解释：

  1. 基本类型就是没有属性和方法的
  2. js为了方便我们操作类型，js会自动创建一个对象
  3. 所以正常书写的属性和方法实际上是这个对象的属性和方法
  4. 当操作完毕，js会自动将这个对象清除

  

- 字符串的不可变性

  - 字符串是无法修改的
  - 后面的所有字符串操作都不可能修改原始字符串值，都是通过返回值返回的处理结果。

- length属性

  - 含义：表示字符串中的字符个数

- 索引操作

  - charAt()
    - 格式：字符串.charAt(索引值)

**操作方法：基本都需要掌握**

- slice(): 拷贝字符串中的部分字符

  - 参数1：开始位置的索引值
  - 结束位置的索引值(不含结束位置)
  - 返回值：拷贝的字符串内容

  

- substr() 拷贝字符串中的部分内容

  - 

- subsrnig()---了解

- indexOf()

- split()

- replace