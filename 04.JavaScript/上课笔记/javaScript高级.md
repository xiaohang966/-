# javaScript高级

## 两大编程思想：万物皆是对象



### 1、面向过程 

`封装方法 按照步骤完成什么功能`  **适用于小的项目**

>  面向过程:分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候在一个个的一次调用就可以



### 2.面向对象  

- Object Oriented Programming，简称 OOP 

`调用方法和属性`  **适用于多人合作的大项目使用的思想**

> 面向对象是把事务分解成为一个个对象， **对象里有各种的属性和方法**，然后由对象之间分工与合作

- 面向对象编程的步骤：
  1. 明确需求
  2. 划分对象
  3. 对象分工
  4. 对象合作
  5. 完成目标

#### 2.1面向对象的三大特性

- **封装性**【功能准备好，直接使用即可】
- **继承性**【功能属性可以继承，可以减少代码重复使用】
- **多态性**【多种形态，可以放到一起使用，也可以单独拿出来使用，单独功能不影响其他功能】



### 2.2面向对象，过程的优点缺点

- **面向过程:** 简单程序
  - **优点：**性能比面向对象高，步骤联系紧密
  - **缺点:**  不易维护，不易多次使用及扩展（性能高，考虑的少）



- **面向对象:**  复杂程序
  - **优点：**容易维护，可复用，可扩展，灵活性高
  - **缺点：**性能没有面向过程快  （考虑的东西多） 



# 3.0 ES6中的类和对象

**类是ES6的概念**，ES5中 一般都是说的对象

### 3.1#类 

- 模拟抽象的，泛指的，对象是具体的
- **面向对象模拟**   贴近现实世界，可分为**抽象对象**和**具体事务**
- 类  涵盖着公共的的属性和方法 这是共有的方法和属性

**面向对象的思维特点**

1. 抽取（**抽取**）对象公用的属性和方法组织（**封装**）成一个类（**模板**）
2. **对类进行实例化，获取类的对象**



### 3.2#对象

1. 具体的事务， 它是类中的具体某个实例【属性和方法的集合体】
2. 在JS 中，对象是一组无序的相关属性和方法的集合，所有的事务都是对象，例如 字符串、数值、数组、函数等。



- **对象**：**由属性和方法组成的**

  - **属性**：事物的特征，在对象中用属性来表示(**常用名词**) 使用起来不带（）

  - **方法：**事物的行为，在对象中用方法来表示(**常用动词**) 使用时带（）



### 3.3#类class

> 可以使用ckass 关键字声明一个类，之后以这个 类 来实例化对象。【构造函数实例化对象】

- 类 里面有对象的公共部分



#### #创建类

>  class 类名{}  // 类名首字母需要大写   

- 这么写相当于语法 糖  （简写）

```js
// 创建一个类class 就里面放的是构造函数
class Star {

}
// 获取，实例化 对象
var str = new Star()
```



#### #构造函数

- **constructor**：构造函数方法
- 构造函数 用来存放对象的 **公共样式和方法** 
- 接受参数，返回实例对象，new 的时候自动执行



**创建类不能使用function  直接加名字  不能加 逗号**  

`每个类都有个构造函数，如果没有就创建`

```js
// 创建类
class Star {
    // 类中会有个自动生成的方法 constructor 构造函数  有类名
    // 设置公共样式   
    constructor (umage,age){
      // this 为当前 new 的实例化对象
      this.umage = umage
      this.age = age
    }
    注意：方法和方法之间不能加逗号
    //增加方法
    chang(){
        console.log(this.uname +'唱歌')
    }
}

// 实例化一个对象
 var liuliu = new Star('刘德华'，22)
 var zxc = new Star('周星期',55)
```



#### #类添加方法

语法：注意方法和方法之间不能加逗号

```JS
//class 类名 { constructor(){}   方法名(){} }
class Star {
	constructor () {}

	sing () {}
    // 方法
	this.sing = function(){
        //这也是方法
    }
}
注意：类中定义属性，调用方法都得用this
```



#### #类的继承

#####  extends ：子继承父

- 可以继承属性
- 当子类没写构造函数时，会自动继承父类的
- 但子类要是有自己的构造函数的时候 就不能继承父类的东西
  - 因为两者的 **this** 的指向不同

```js
// 语法：
​	class Father {}
​	class Son extends Father{}
// 注意：是子类继承父类
// 正常是子类继承属性的时候 直接使用就可以

```

**注**：当子类没有constructor的时候可以随意用父类的，但是如果子类也含有的话，constructor会返回实例，this的指向不同，不可以再直接使用父类的东西



##### super 关键字  

> **在子类，父类都有construction 时子类就不能直接继承父类的属性**
>
> **使用 super 可以在这种的时候调用**

```js
// 在子类，父类都有 construction 构造函数时 子类继承父类的方法
//父类
class F { constructor(name, age){} }

// 子类
class S extends F { 
constructor (name, age) {
    // super中的参数 就是父类的参数
    super(name,age); 
	}
}
```



**继承方法:** 

- 子类父类都可以拥有自己的方法 
- 方法名字可以相同
- 调用时会就近原则

```js
class F { constructor(name, age){} say () {} }

class S extends F { 
constructor (name, age) { 
    super(name,age); 
    } 
    say ()  { 
       super.say()
       } 
     }

// 注意：如果子类也有相同的方法，优先指向子类，就近原则
```

**super调用父类的属性和方法，那么查找属性和方法的原则就近原则**



## 三个注意点

- 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.
  - **必须先创建类 才能实例化**
- 类里面的**共有属性和方法****一定要加this使用**.【this，对象调用属性和方法】按钮练习
  - **在对象和属性中 必须使用this调用才可以**
- 类里面的this指向问题. 
  - **构造函数的this指向实例对象**
  - **普通函数的this是调用者，谁调用this是谁**
- constructor 里面的this指向实例对象, **方法里面的this** 指向这个方法的调用者



### 插入元素里面

- 将制定的文本解析为HTML或XML（），将结果节点插入到DOM树种的指定位置
- 它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。
- 避免了额外的序列化步骤，使其比直接innerHTML操作更快。

```js
element.insertAdjacentHTML(position, text);

//position 位置      text:内容
'beforebegin'
元素自身的前面。
'afterbegin'
插入元素内部的第一个子节点之前。
'beforeend'
插入元素内部的最后一个子节点之后。
'afterend'
元素自身的后面。
```



# 4.0 构造函数和原形

**ES5 常用的创建对象的方法：3种**

- 自面量创建对象 ：属性和方法
  - 直观就能观测到数据类型就是**字面量数据**
- 构造函数： 添加进去的属性 和方法  
  - `var obj = new Object`
  - 属性：`obj.name = '数据'`
  - `obj.feidao = function(){}`
  - 访问 ` obj.feidao`
  - 使用 `obj.feidao()`
- 自定义构造函数
  - `function P (形参，形参){`
  - `属性   方法}`
  - `new p(传参)`

## #构造函数

```js
// 构造函数 也是函数
1.构造函数是一种特殊的函数，
2.主要用来初始化对象，即为对象成员变量赋初始值，它与new一起使用，就是构造函数。
3.可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。
4.构造函数没有返回值
```



## #new 

1. 会内存中创建一个新的空对象（空间）。
   - 指向的是地址  new之后就会开辟一个新的空间
2. **this会指向这个新的对象**。
3. 执行构造函数里面的代码，给这个新对象添加属性和方法。
4. 返回这个新对象（所以构造函数里面不需要return）。



## #实例成员和静态成员

- **静态成员**：在构造函数本上添加的成员称为静态成员，**只能由构造函数本身来访问**
- **实例成**员：在构造函数内部创建的对象成员称为实例成员，**只能由实例化的对象来访问**



## # 原型对象的构造函数

​	**prototype**

- **原型对象**：是构造函数的属性，这个属性是一个对象，也称呼，prototype 为原型对象。
- **作用**：是为了共享方法，从而达到节省内存

> 构造函数通过原型分配的函数是所有对象所共享的。这个对象的所有属性和方法，都会被构造函数所拥有,可以把那些不变的方法，直接定义在prototype 对象上，这样所有对象的实例就可以共享这些方法

**注意：每一个构造函数都有prototype属性**

```js
//把方法放进 prototype 对象上
function Star (uname, age) {
​		this.uname = uname;
​	}
 // 把方法（函数）存在 原型对象上( prototype )
​	Star.prototype.sing = function () {
​		console.log(this.uname + '在唱歌');
​	}
​	var ldh = new Star('刘德华', 22);
//  实例化对象上虽然没有方法，但是能调用原型对象上的方法
​	ldh.sing();
​	zxc.sing();
```

**总结：所有的公共属性写到构造函数里面，所有的公共方法写到原型对象里面**



## #对象原型

> 疑问：为何创建一个对象，都可以自动的跑到原型对象上找方法
>
> **因为每一个对象都有一个属性，对象原型，执行原型对象**

**— proto —** 

> 构造函数和原型对象都会有一个属性__proto__ 指向构造函数的prototype 原型对象，

> 之所以对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有__proto__ 原型的存在。

- **作用:** 指向原型对象 prototype 
- **每一个对象都有一个原型（-proto-），作用是指向原型对象prototype**

- **注意: **  **是一个非标准属性，不可以拿来赋值或者设置【只读属性】**

  - **统一称呼：proto原型，prototype成为原型对象**

  

```
1.____proto____对象原型和原型对象prototype 是等价的

2.____proto____对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype
```



## #ES5 中的构造函数

> <u>**记录是哪个构造函数创建出来的**</u>
>
> 指回构造函数本身

```js
原型（proto）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor 我们称为构造函数，因为它指回构造函数本身。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。
```

注：**在ES5中constructor  主要作用可以指回原来的构造函数**

- 正常书写格式 把方法 放在原型对象（prototype）

```js
Str.prototype.taiji = function() {}   // 这个写法会有 construction 属性
```



- 但这么创建方法不可能就一个，那么就可以换个方法写

```js
// 相当于 对象赋值 那么就会重新赋值 就不会有 construction 属性
Star.prototype = {
    sing : function () {},
    dance: function () {}
};

Star.prototype = {
    // 对象写方法 会把对象上的方法给覆盖掉 所以我们需要自己添加方法
    // 设置 constrution 指向自己构造函数 （就是这个方法 是哪个构造函数的方法）
    construction:Str  //构造函数
    sing : function () {},
    dance: function () {}
};
```

```js
一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor 指向原来的构造函数。
```



## #原型链

>  作用：提供一个成员的查找机制，或者查找规则

- 自己有，先用自己的 没有就往上找

```js
 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。

 如果没有就查找它的原型（也就是__proto__指向的prototype 原型对象）。

 如果还没有就查找原型对象的原型（Object的原型对象）。

 依此类推一直找到Object 为止（null）。

 __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。

// console.log(Star.prototype.__proto__.__proto__);
// console.log(Object.prototype);
```



## #扩展内置对象

> 可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。

```js
// 在原型对象上增加一个方法
Array.prototype.sum = function () {
		var sum = 0;
		for (var i = 0; i < this.length; i++) {
			sum += this[i];
		}
		return sum;
}

Math 为特殊的对象 它是字面量对象 直接使用就可以
```



## #继承

> ES6之前并没有给我们提供extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承



### #属性继承

>  使用call继承父类的属性

```js
call()

调用这个函数, 并且修改函数运行时的this 指向
// fun: 父类    
fun.call(thisArg, arg1, arg2, ...);call把父类的this指向子类

thisArg ：当前调用函数this 的指向对象

arg1，arg2：传递的其他参数
```





### #方法继承

> 实现方法把父类的实例对象保存给子类的原型对象

**用构造函数实线属性继承，用原型对象实线方法继承**

```js
//让子类能继承父类的方法
//1.子类也拥有原型对象(prototype)可以通过 字符串赋值的方法 拿到父类的原想对象上的方法(prototype)，但这样做，子类自己的方法 就会被覆盖 而且父类的 方法也会被同化
//2.但可以使用  子类的 原型对象(prototype) = 父类的 实例化对象 这样有一个中转站，父类的 方法就不会被影响

//3.但是此时 子类的 子类的方法自己调用不了，因为子类的原型对象(prototype)的属性，没有construction这个属性，那么从新设置之后指向自己 ，

//4.此时的子类 可以使用父类的方法 ，继承下来了方法， 自己的方法也能使用

一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。核心原理：

①将子类所共享的方法提取出来，让子类的prototype 原型对象= new 父类()  

②本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象

③将子类的constructor 
```

```js
// 子类继承父类的方法
function Father () {

		}
	// 父类的方法
		Father.prototype.chang = function ()         {console.log('唱歌');}
		
   // 子类
		function Son () {}
   // 子类继承父类的方法 
		Son.prototype = new Father();
   // 必须找回自己 否则就不能使用自己的方法
		Son.prototype.constructor = Son;
		var obj = new Son();
		obj.chang();

		Son.prototype.score = function () {
			console.log('考试');
		}

```





### #类的本质

```js
class类 本质还是function

类的所有方法都定义在类的prototype属性上

类创建的实例,里面也有__proto__ 指向类的prototype原型对象

所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

// 所以ES6的类其实就是语法糖.

语法糖:语法糖就是一种便捷写法.   简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖
```





## #ES5 中的新增方法

### #数组方法

> ES5 类似 jQuery 语法糖的遍历数据的方法
>
> 迭代(遍历)方法：**forEach()、map()、filter()**、**some()**、every()；



#### **#forEach()**

`数组方法： 就是为了数组拿到(遍历)数据`

```js
// 例子
var arr = ['red','blue','yellow','orange'];

arr.forEach(function (val,index,arrAbc) {
	console.log(elm,i,arrAbc);
});

// val：数组遍历出来数据的 当前项的值
// index：数组遍历出来数据的当前项的索引
// arr：使用的数据本身(相当于标记)
```

> forEach 遍历数据 判断需要使用 if（） 但是没有 return值  ？？



#### #filter()

`数组方法：可以筛选数组，并返回一个 新的数组`

```js
var arr = [100,66,99,123,333,33,44,66];
var reArr = arr.filter(function (val, index, arr) {

// 按照判断结果 并把符合要去的数组 变成新的数组并返回出去
   return elm % 2 == 0;
	
});
   console.log(reArr);
// 注意它会直接返回一个新数组

// val：数组遍历出来数据的 当前项的值
// index：数组遍历出来数据的当前项的索引
// arr：使用的数据本身(相当于标记)
// return：返回值(符合要求的值装入新的数组中) 
```



#### #some()

`数组方法: 检测数组中是否有符合要求的 数据，有的话立即停止`

**【注意：找到或者满足条件立刻停止】**

```js
// 取值 
var arrAte = []

var arr = [100,200,300,400];
var re = arr.some(function (val, index, arr) {
	
    // 看看是否有200 并立刻停止 不会再遍历后面的数据
	 // return val == 200;
    // 如果 return 为false 会接着运行
    
    // 拿到符合的数据
    if(val = 2){
        arrte.push(val) 
    // 并停止遍历
    }
	});
console.log(re);

// 1.0 some() 方法用于检测数组中的元素是否满足指定条件. 通俗点查找数组中    是否有满足条件的元素
// 2.0 注意它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找   不到就返回false.
// 3.0 如果找到第一个满足条件的元素,则终止循环. 不在继续查找.
// currentValue: 数组当前项的值index：数组当前项的索引
// arr：数组对象本身
```



### #字符串方法

**trim方法：**去除字符串中的 **前后空格（默认值）**

```
str.trim() 
trim:删除字符串两侧的空白符
```





# #函数方法--》进阶

## #函数的定义和调用

1. 函数声明方式function 关键字(命名函数)

2. 函数表达式(匿名函数)【自调用函数】

3. ```
   new Function()   var fn = new Function('参数1','参数2'..., '函数体')
   
   var fn = new Function('a','b','console.log(a,b);');
     
   fn(123,456);
   ```

4. Function 里面参数都必须是字符串格式

5. 第三种方式执行效率低，也不方便书写，因此较少使用

6. 所有函数都是Function 的实例(对象) 

7. 函数也属于对象



## #函数的调用

```js
1. 普通函数【fn()】
2. 对象的方法【obj.taiji = function () {}：(obj.taiji())】
3. 构造函数【function Star () {}：new Star()】
4. 绑定事件函数【btn.onclick = function () {}：btn.onclick()】
5. 定时器函数【window.setInterval(function () {},1000)】
6. 立即执行函数【(function () {})()】
```



## #this指向

**this：当前调用者**

- 普通函数中调用this  ==》 window
- 构造函数调用 ==》实例化对象 
  - 原型对象里面的方法也指向实例对象
- 对象方法调用  ==》 该方法所属对象
-  事件绑定方法 ==》  绑定事件对象（**事件源**）
- 定时器函数 ==》 window
- 匿名函数 (立即执行函数)  ==》 window



## #改变函数内部的this 指向

> 处理函数内部this 的指向问题，常用的有bind()、call()、apply() 三种方法。



## #call 方法    

> 只有在函数中 才有this   只要是函数就有this  那么就可以改变this 的指向

```js
// 多用于 函数的继承  或者说是构造函数 继承
call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this 指向。

fun.call(thisArg, arg1, arg2, ...)
thisArg：在fun 函数运行时指定的this 值

arg1，arg2：传递的其他参数
返回值就是函数的返回值，因为它就是调用函数

function Father () {this}
function Son () { Father.call(this,1,2) 

对象：父类中有函数   子类想要继承父类中的函数  
    父类函数的名字.call(this,父类的函数参数)
// 因此当我们想改变this 指向，同时想调用这个函数的时候，可以使用call，比如继承
```



## #apply 方法

> 配合数组使用

```js
fun.apply(thisArg, [argsArray]):调用函数

thisArg：在fun函数运行时指定的this值

argsArray：传递的值，必须包含在数组里面

返回值就是函数的返回值，因为它就是调用函数

因此apply 主要跟数组有关系，比如使用Math.max() 求数组的最大值

var obj = {name : '张三丰'}
	function fn (arr) {
		console.log(this);
		console.log(arr);
		console.log(arr2);
	}
	//#################################################
	var arr = [23,45,56,23,54];
	// 指向的内容 需要是有效的 或者说变量好的
	var n = Math.max.apply(null,arr);

	console.log(n);
```



## #bind 方法

> 

```js 
// bind() 方法不会调用函数。但是能改变函数内部this 指向

fun.bind(thisArg, arg1, arg2, ...)

thisArg：在fun 函数运行时指定的this 值

arg1，arg2：传递的其他参数

返回由指定的this 值和初始化参数改造的原函数拷贝

因此当我们只是想改变this 指向，并且不想调用这个函数的时候，可以使用bind

var btn = document.querySelector('input');

		btn.onclick = function () {
			this.disabled = true;
			window.setTimeout(function () {
				this.disabled = false;
			}.bind(btn),2000);
	}
```



```
fun.call(obj,arg1,arg2......);
fun.apply(obj,[a,b,c])
fun.bind(obj,arg1,arg2......);
```

```js
// 相同点:  都可以改变函数内部的this指向.

// 区别点:  
1.call 和apply  会调用函数, 并且改变函数内部this指向.
2.call 和apply 传递的参数不一样, call 传递参数aru1, aru2..形式apply 必须数组形式[arg]
3.bind  不会调用函数, 可以改变函数内部this指向

主要应用场景:  
1.call 经常做继承. 
2.apply 经常跟数组有关系.比如借助于数学对象实现数组最大值最小值
3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向
```





# 严格模式

JS：两种模式[类似于HTML版本]

​	1、正常模式

​	2、严格模式

```js
严格模式在IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。
严格模式对正常的JavaScript 语义做了一些更改：

1.消除了Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。【例如变量，不声明就报错】
2.消除代码运行的一些不安全之处，保证代码运行的安全。
// 3.提高编译器效率，增加运行速度。
4.禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名
```



**开启严格模式："use strict"**

```js
// <script>"use strict"</script>：脚本开启严格模式
	<script>function fn () {"use strict"}</script>为函数开启严格模式
```

> 严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。

## **为脚本开启严格模式**

```js
//为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。

<script>
	"use strict";
	console.log("这是严格模式。");
</script>

因为"use strict"加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。
```



## **为函数开启严格模式**

```js
要给某个函数开启严格模式，需要把“use strict”;  (或'use strict'; ) 声明放在函数体所有语句之前。

function fn(){"use strict";return "这是严格模式。";}

将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。
```



# 严格模式中的变化

> 1.变量必须带 var ，而且变量不可以删除
>
> 2.严格模式下的函数中的this 指向 undefiend  
>
> 3.构造函数正常模式下，如果当成普通函数用 那么就会报错
>
> ​	如果不构造函数不指向实例化对象，那么就报错



- **变量规定**
  - .变量必须带 var ，而且变量不可以删除（定义变量还删除 那为什么还定义）



- **this指向问题**
  - 普通函数this是undefined
  - 造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错
  - 定时器this 还是指向window 。
    事件、对象还是指向调用者。



- **函数的变化**
  - 参数不能重名
  - 函数必须声明在顶层
  - 【if，for等里面定义函数也不可以，但是现在不可以】
  - 错误写法:
    function fn (a,a) {console.log(a+a);}
    fn(1,2)





# 高阶函数

> 高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。
>
> 函数作为参数被其他参数使用，或者是函数 作为返回值使用

```js
// 高阶函数   回调函数   调用的是地址

第一种写：函数 作为参数被传参
*************************************************
function fn(k){
  //函数调用
    k()
}
fn(sum)
var sum = function(){}

第二种写法  寻找变量名为 sum 的变量 没有就找 变量为sum的函数
**************************************************
function dun(n){
// 有叫n 的变量就调用
// 要不然就调用 名字 叫 n 的函数
    sum&&sum()
}
var sum = function(){}

第三种方法 函数作为返回值使用
***************************************************
function fn(k){

 result  function(){}
}
fn(sum)
var sum = fn()  // 接受到返回值
sum()  调用函数
```





# #闭包

`闭包是一种现象`

变量作用域**

> 变量根据作用域的不同分为两种：全局变量和局部变量。
>
> 1. 函数内部可以使用全局变量。
> 2. 函数外部不可以使用局部变量。
> 3. 当函数执行完毕，本作用域内的局部变量会销毁



在闭包环境中，内部函数 被当成返回值得时候

此时 外部函数直接调用的话 打印的是内部体

不接受 内部代码也就执行不了

## # 什么是闭包

- **闭包（closure）指有权访问另一个函数作用域中变量的函数。【很多种解释，都并不权威】**
- **简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。**
- 闭包针对变量 

```js
	function fn1(){
		// fn1 就是闭包函数
		var num = 10;
		function fn2(){
			console.log(num); // 10
		}
		fn2()
	}
	fn1(); // 闭包函数
```



**思考：如何再函数外面访问到函数内部的变量**

```js
// 在闭包里 函数里面的函数 如果不调用 那么里面的值就会一直保存

function fn () {
		var i = 7;
     // 此时外面能访问到这个函数   
		return function () {
			console.log(i);
		}
	}
	var n = fn();
n();
// 此时 n 不被调用 但是它还是等于 函数fn里面的匿名函数
// 此时就相当于 匿名函数被保存  相当于可以不使用就一直在	
```



## # 递归

> 递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数

**递归：函数调用函数其本身**

`**注意：**递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。`

```js
// 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数

// 利用递归求1~n的阶乘

//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
 function fn(n) {
     if (n == 1) { //结束条件
       return 1;
     }
     return n * fn(n - 1);
 }
 console.log(fn(3));
********************************************************
利用递归遍历数据

		var data = [
			{
				id : 1,
				name : '家电'
			},
			{
				id : 2,
				name : '服饰'
			}
		];
var data = [{
   id: 1,
   name: '家电',
   goods: [{
     id: 11,
     gname: '冰箱',
     goods: [{
       id: 111,
       gname: '海尔'];
//1.利用 forEach 去遍历里面的每一个对象
 function getID(json, id) {
   var o = {};
   json.forEach(function(item) {
     // console.log(item); // 2个数组元素
     if (item.id == id) {
       // console.log(item);
       o = item;
  
       // 2. 我们想要得里层的数据 11 12 可以利用递归函数
       // 里面应该有goods这个数组并且数组的长度不为 0 
     } else if (item.goods && item.goods.length > 0) {
       o = getID(item.goods, id);
     }
   });
   return o;
}
```



# # 深拷贝和浅拷贝

- 对象之间的拷贝数据方式
  - 相等  =  赋值的形式会让复杂数据的地址相同



## #浅拷贝

> 拷贝数据外层数据(属性可以拷贝，方法里面的数据不能直接拷贝)

```js

var obj = {
			name : '张三丰',
			age : 22
		};
// 对象直接赋值 也就是数据地址相同，为了互相不影响，那么就需要换个方法
// 拷贝对象的每一个属性
		for (key in obj) {
            // 空的对象中的 键名等于 有数据的对象的键名
			newObj[key] = obj[key];
		}

		console.log(newObj);
		
es6：新方法
// 直接进行浅拷贝
Object.assign(target, sources);
// sources  我是有数据的对象
// target 我是空的对象 
console.log(newObj);
```



## #深拷贝

> 浅拷贝数据，只是拿到外层数据，如果是数据类型比较复杂，但还想都要数据，那么就需要   深拷贝

- 深拷贝没有直接方法 需要自己写

```js
// 逻辑
var obj = {
			name : '1张三丰',
			age : 22,
			messige : {
				sex : '男',
				score : 16
			},
			color : ['red','purple','qing']
		}
		var newObj = {};
			
		function kaobei (newObj,obj) {
        // 遍历拿到对象中键上的数据 并拿到他赋值到空的对象 ：深拷贝的前题
			for (key in obj) {
                // 确定一下 此时被复制对象的数据 是什么格式的
				if (obj[key] instanceof Array) {
                // 检索数据格式 ，如果数据 是数组的话怎么做
					newObj[key] = [];
					kaobei(newObj[key],obj[key]);
                    
				} else if (obj[key] instanceof Object) {
                    // 检索数据格式 ，如果数据 是对象的话怎么做
					newObj[key] = {};
					kaobei(newObj[key],obj[key])
				} else {
					newObj[key] = obj[key];
				}
			}
		}
		obj.messige.sex = 99;
		kaobei(newObj,obj);
		console.log(newObj);
```



# #正则表达式概述

- **什么是正则表达式：**

  正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式

- **作用：**

  检索关键字，过滤敏感字符，**表单验证**

- **描述：**

  **正则表通常被用来检索、**替换那些符合某个模式（规则）的文本，例如**验证表单**：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。

  

- **特点**：

  - **灵活性、逻辑性和功能性非常的强。**
  2. 可以迅速地用极简单的方式达到字符串的复杂控制。
  3. 对于刚接触的人来说，比较晦涩难懂。比如：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$
  4. 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:   /^[a-z0-9_-]{3,16}$/

  

  1.大括号  量词符.  里面表示重复次数

  2.中括号 字符集合。匹配方括号中的任意字符. 

  3.小括号表示优先级

  

### 正则表达式在js中的使用

- **创建正则表达式:**

```js
在 JavaScript 中，可以通过两种方式创建一个正则表达式。

方式一：通过调用RegExp对象的构造函数创建 

    var regexp = new RegExp(/123/);
    console.log(regexp);

方式二：利用字面量创建 正则表达式

     var rg = /abc/; 含义：只要包含abc就可以
 数据格式不能是 a1b2c3 
```



- **测试正则方法**

```js
   test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串
 // 正则里面没有引号
regexObj.test(str);
```



### #正则表达式中的特殊字符

- **元字符**
  - 特殊字符

```js
个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。

// 正则表达式：简单字符 和 特殊字符【元字符】
jQuery 手册：正则表达式部分

正则测试工具 ： http://tool.oschina.net/regex
```



- **边界符**
  - **如果 ^和 $ 在一起，表示必须是精确匹配。**

```js
正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符

^ : 表示匹配行首的文本（以谁开始）【/^abc/：以abc为开头】

$：表示匹配行尾的文本（以谁结束）【/^abc$/：只能是abc】

^$ : 表示输入内容只能是什么内容(精确匹配) 【/^abc$/: 内容只能是】
```



### 字符类

> 符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。



### [] 方括号

- 表示有一系列字符可供选择，只要匹配其中一个就可以了【多选1】

```js
var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true

var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true

var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  

//字符组合
var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true 

//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 
/^[^a-z]$/：两个^，括号外面的是便边界，括号里面的是取反的含义
```



### 量词符

> 词符用来设定某个模式出现的次数。

```js
/^[a-z]*$/
*		重复0次或更多次【>=0次】

/^[a-z]+$/
+		重复1次或更多次【>=1次】

/^[a-z]?$/
?		重复0次或1次

/^[a-z]{3}$/  //出现 3次
{n}		重复n次

/^[a-z]{3,}$/
{n,}	重复n次或更多次

/^[a-z]{3,6}$/  //3到6次
{n,m}	重复n到m次
注意：{n,m}n和m之间不准有空格
```



正则表达式在线测试 ： https://c.runoob.com

### 预定义类

预定义类指的是某些常见模式的简写方式.

```php
.（点）  [^\r\n]            除了回车符和换行符之外的所有字符

\d      [0-9]              数字字符

\D      [^0-9]             非数字字符

\s      [\t\n\x0B\f\r]     空白符

\S      [^\t\n\x\0B\f\t]   非空白符

\w      [a-zA-Zz_0-9]      单词字符（字母、数字下划线）

\W      [^a-zA-Zz_0-9]     非单词字符
```

