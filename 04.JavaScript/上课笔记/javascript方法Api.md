￥#WebApi

**网页三要素：**HTML(骨架内容) + CSS(样式)  + javascript(行为)

**1.JS组成部分**

- EMCAScript 提供了javascript 的基础语法
  - 变量：用于存储数据：
  - 数组类型： 
    - 简单类型() 
    - 复杂类型()

- DDOM-document object model 文档对象模型
  - 把这个页面看成一个对象(document)
  - 提供了操作文档的API
- BOM-browser object model  浏览器对象模型
  - 把浏览器看成一个对象(window)
  - 提供了操作浏览器的API



**2.API：**

- 官方定义: API - (application programing interface) 翻译过来叫 **应用编程接口**
- 解释：官方提前准备好的方法，我们可以直接拿过来用比如: **Math.random()**



3.WeAPI:

> WebApI :浏览器的提供的两类（DOM控制HTML和BOM控制浏览器）内置方法



## #1.DOM--DOM树

 

#### 1.1#DOM

- **描述**：别人封装好的操作  **HTML**  的方法，直接调用即可   比如:设置HTML 中的某个标签的背景颜色

- > 概念：文档对象模型。【document object model】

  ​	【JS操作页面元素的一套规则，标准】

  > - 文档：html文件
  > - 对象：属性和方法
  > - 模型：（树）

- **用法**：

  > 函数调用的方法  如：获取一个DOM元素--- documentElementById('id类名')

  

- **学DOM 做什么？**
  
  - 获取元素
  - 给元素注册事件
  - 操作元素的属性
  - 动态操作元素（创建、追加、删除、克隆等）



#### 1.2#DOM树--文档树

> 文档树：浏览器在加载html文件时，会把文档、文档中的标签、属性、文本、注释转换成对象，然后按照标签的关系（父子、兄弟、祖孙）以树状结构存储到内存中。



文档树中的对象，也被称为**节点对象**  。

节点对象的分类：==**文档（document）**==   、==**元素（标签转换的对象）**== 、**文本、属性、注释**



## #2获取元素--页面元素

> 获取元素的套路：1.在某个元素对象中元素查找具体元素  2.调用的方式
>
> 怎么获得：能够通过ID 属性获取元素 ， 能够通过标签名获取元素，能够通过类名获取对象，获取body元素

#### 2.1 通过 ID值 获取元素

- **语法:**

> document.getElementById("id类名")

- **参数:**
  - 类型：字符串
  - 值：id属性值
- **返回值**
  - 类型：会返回一个  **对象**

- 代码： 一定要在document下调用getelementById配合使用，才会返回元素对象

```html
 <button id="btn">按钮1</button>
 <button id="btn">按钮2</button>
 <script>
   // 根据id获取单个元素，返回一个元素
   var btn = document.getElementById('btn');
   // dir可以打印出对象中的属性和方法
   console.dir(btn);
   console.log(btn);
   // 细节：若页面上有相同的id值的标签时，在获取时，获取的是id值第一次出现的标签。
 </script>
```

#### 2.2-通过标签名获取元素

- 语法：document.getElementsByTagName('标签名')
- 参数：
  - 类型：字符串
  - 值：标签名 ---body，div，p，....
- 返回值：
  - 类型：伪数组
  - 值：符合要求的元素对象的集合
- 注：
  - 获取元素内容中的元素，需要先获取元素之后才能获取
    - 否则获取的元素是个伪数组
    - 但要是先获取父元素在获取子元素 那么就可以单独获取父元素下的子元素
  - getElementsByTagName() --**element会加s** ++ 因为元素会有多个
  - 不一定是在document下获取，也可以在其他元素下获取某一类标签元素
  - 返回的数据是伪数组数据
    1. 想要获取某个具体元素对象需要使用下标 elemenet.getElementByClassName('标签名')
    2. 获取伪数组中含有元素对象的个数elementsByClassName('标签名').length
    3. 可通过for循环的方式获取每一个元素'for(var i = 0;i<elements.length;i++){elements[i]}'
    4. 由于是伪数组，所以不能使用数组的内置方法
- 例子：

```html
1.创建两个ul，id分别为'first' 和 'second',在ul内部分别创建4个li
2.获取所有li，获取'second'中的第二个li
```



#### 2.3-通过类名获取元素 -- class类名 

- **语法**：`element.getElementsByClassName(‘类名’)`
- **参数**
  - 类型：字符串
  - 值：class属性值
- **返回** 
  - 类型：**伪数组**
  - 值：符合要求的元素对象的集合
- **注意**
  - `getElementsByClassName()`     因为元素有多个  所以element+s
  - 不一定是在document下获取，也可以在其他元素下获取某一类标签元素
  - 返回数据是伪数组数数据
    1. 想要获取某个具体元素对象需要使用下标 `element.getElementsByClassName('标签名')[index]`
    2. 获取伪数组中含有元素对象的个数 `element.getElementsByClassName('标签名').length`
    3. 可通过for循环的方式获取每一个元素 `for(var i = 0;i<elements.length;i++){elements[i]}
    4. 由于是伪数组，所以不能使用数组的内置方法
- **例子**

```html
1.创建两个ul,,在ul内部分别创建4个li
2.获取'second'中的所有li
```



#### 2.4获取body元素

- 语法**：`document.body`
- **返回**
  - 类型：对象
- 值：body元素
- **例子：**

```html
<body>
    我是body
    <div>我是div</div>
    <script>
		console.log(document.body) 
	</script>
</body>
```



## #3.0事件

#### 3.1概念：

- 官方：触发-响应的过程
- 简述：当用户某个页面元素进行某种操作(鼠标点击，划过)时，网页做出相应的回应    比如：在用户点击某按钮时产生一个事件，然后去执行某些操作

#### 3.2事件三要素

- **事件源**（谁，具体的哪个元素）
- **事件类型**（监控用户对这个元素的某种操作）
- **事件执行程序**（一旦用户对该元素有监控的行为，要干什么事情）

**代码：**

```javascript
 // 获取按钮元素
 var btn = document.getElementById('btn');
 btn.onclick = function(){
   // 函数体中的代码，就是事件发生后要执行的程序
   alert('燃烧段段的卡路里');
 };

 // 事件处理程序的本质是什么？
 // ① onclick本质上就是事件源这个对象中的某一个键值对而已。默认值是null，表示没有注册事件
 // ② 给事件源注册onclick事件，其实本质上就是给onclick赋值函数，所以onclick是事件源的一个方法而已
 // ③ 点击按钮时，浏览器自动调用了btn.onclick();
```



#### 3.3事件处理程序中的this

> 关键词：this 指向事件源 

```javascript
 // 获取按钮元素
 var btn3 = document.getElementById('btn');
 btn3.onclick = function(){
   // 函数体中的代码，就是事件发生后要执行的程序
   // 关键字：this，代表事件源
   console.log(this);
 }
```



#### 3.4 注册事件

- **步骤**
  - 获取具体的某个元素**对象**
  - 绑定某个类型的事件
  - 添加事件处理程序（采取函数赋值形式）
- **语法**：`事件源.on+事件类型 = 函数名 / 匿名函数`
- **事件处理函数中的this**：代表事件源（就是绑定事件的元素）



#### 3.5 事件类型

- 点击**：click
- **input获得焦点**：focus
- **input失去焦点**：blur

  



## #4. 操作元素标准属性

> 目标：能够通过操作元素的标准属性，完成对网页样式、内容的修改

- **操作元素属性步骤**：① 获取需要操作的元素 ② 操作元素的属性
- **标准属性**：元素自带的属性 （可读可写）
- **获取语法**：`element.属性名`
- **设置语法**：`element.属性名 = ‘属性值’`

#### 4.1 操作元素内容

- **普通元素内容设置**（div 、p、span、a.....）
  - `element.innerHTML = '内容' `**识别标签、空格  经常使用**`
  - `element.innerText = '内容'`   
- **表单元素**   (input、textarea)
  - `element.value = '内容'`



#### 4.2 操作元素样式

- 操作style属性，修改行内样式，**优先级高**

  - `element.style = 'css属性名1:属性值；css属性名2：属性值'`

  - `element.style.css属性名 = '属性值'`  **设置单个样式 **   如果样式用-连接 则需要用驼峰方式设置

    

- 操作class属性，修改样式

  - `element.className = '类名1  类名2  类名3 '`  **设置多个样式**  **会刷新元素的class属性**

  - `element.classList`   **设置多个样式**
- 添加类 `element.classList.add('类名1','类名2','类名3')`
    - 移除类 `element.classList.remove('类名1','类名2','类名3')`
    - 切换类 `element.classList.toggle('类名')`  :元素存在该属性删除该属性，不存在该属性添加该属性        
    - **案例：搜索历史提示**

#### 4.3 操作元素常用属性

- `element.src = '属性值'`

- `element.disabled = true/false`

- `element.checked = true/false`

  


## #5.操作元素自定义属性

> 元素添加自定义属性，相当于能加上属性，也能拿下去

#### 5.1 H5方法(不兼容ie6，ie7，ie8)

- 语法：` <p data-自定义属性名 = '自定义属性值'> </p>`
- 获取语法：元素名.dataset.自定义属性名
  - 属性名没有限制，可以多个连接-` <p data-自定义属性名  自定义属性名 = '自定义属性值'>



##### 5.2 无兼容性方法(不常用)

- 语法：` <p 自定义属性名-自定义属性名 = '自定义属性值'> </p>`
  - 跟 `dataset-` 用法差不多，但是属性获取不方便,直接访问：`undeflined`

#### 5.3 操作元素所有(标准，自定义) 属性:万能选择器

> 包含无兼容性问题的自定义属性

- 获取元素属性：`元素.getAttrbute('属性名')`

  - 能获取元素中的某个属性值
  - 哪种元素都能获取到

  

#### 5.4 设置元素属性 万能方法

- 语法**：`元素.setAttribute('属性名','属性值')`
- 哪种元素都能设置



#### 5.5 删除元素属性万能方法

- 语法**：`元素.removeAttribute('属性名')`

- 哪种元素都能删除

- 属性：

  - 类型：字符串

  - 值：属性名   属性值

    

## #6.获取(css选择器方式)

#### 6.1获取符合css选择器的第一个元素

- **语法**：`element.querySelector('css选择器')`
- 符合CSS选择器要求的第一个元素
- **值**：css选择器  class 直接获取就行   id需要元素前加上 #



#### 6.2获取符合CSS选择器的所有元素

- **语法**：`element.querySelectorAll('css选择器')`

- 获取符合选择器要求的所有元素



## #7.事件高级

### 7.1 注册事件的两种方式

##### #DOM0级事件(on)

- **语法:**`元素.on+事件类型 = 函数名/匿名函数`
- 特点**：同一个元素只能注册一次某个类型的事件，多次注册，只有最后一次添加的事件有效,之前的都会无效



#####   #DOM2级事件(addEventListener)

- **语法：**`元素.addEventListener('事件类型'，函数名/匿名函数)`

- **参数**
  - 第一个：字符串    事件类型 **不加on**
  - 第二个：匿名函数/函数名（事件执行程序）
- **特点**：同一个元素能注册多个某种类型的事件，多次注册，事件触发时，会按照注册的先后顺序依次执行



### 7.2 接触事件的两种方式

##### #DOM 0 级事件解除方式(on)

- **语法**：`element.on+事件类型 = null`

- **原理：**DOM0级事件特点是多次绑定事件后面覆盖前面的，所以会失效



##### #DOM2级事件解除方式**（removeEventListener）

- **语法**：`element.removeListener('事件类型'，函数名)`



**注意：想要解除某个事件，前提是这个事件注册时添加的事件处理函数是有名函数**



## #8.DOM 事件流

- **定义：**事件发生时会在元素节点之间按照特定的顺序传播，这个过程就是**DOM 事件流**

- **DOM事件流的三个阶段**

  当一个DOM事件触发时，它不是在触发的对象上只触发一次的，而是三个阶段。

  1. 一开始从文档的**根节点流向目标对象**(**捕获阶段**)
     - 特点：在这个阶段，触发某个元素的事件，其所有元素上绑定的相同类型的事件都会触发，且先执行父级事件
  2. 然后在目标对象上被触发(**目标对象**)
  3. 最后再回溯到文档的根节点（**冒泡阶段**）
     - 特点：在这个阶段，触发某个子元素，其所有父元素上绑定的相同类型的事件都会被触发，先执行子元素事件再执行父元素事件

#### 8.1捕获事件和冒泡事件

由于一个DOM事件触发时只能监听事件传播的一个阶段，要么是捕获阶段，要么是冒泡阶段，因此将DOM事件分成了两类，捕获事件和冒泡事件

- **捕获事件**

  `addEventListener('事件类型',函数名/匿名函数,boolean)给元素绑定事件,当第三个参数`

**true：该事件就是捕获事件**

**false:（不写默认就是false）,该事件是冒泡**

```
  1.创建三个关系是子级、父级、爷爷级别的div元素
  2.分别给这个三个元素添加点击事件且该事件是捕获阶段
```



- **冒泡事件:**

  `elemeent.on+事件类型 =函数名/匿名函数给元素绑定的事件,这种都是冒泡事件`

```
1.创建三个关系是子级、父级、爷爷级别的div元素
2.分别给这个三个元素添加点击事件且该事件是冒泡阶段
```



#### 8.2冒泡的事件的影响

> 由于事件冒泡阶段具有点击某个子元素，其父元素上绑定的点击事件也会触发的特点，有时需要利用这个特性，或者避开它

- **利用:**事件委托
  - 解决的问题：
    - 同事给100个**li**元素添加点击事件:遍历添加事件消耗性能多
    - 给动态生成的元素添加事件:由于事件是先绑定的，如果动态添加元素，就需要每添加一个,就绑定一次事件 消耗性能多
  - **原理:**为了给子元素添加事件，可以将事件委托给父级，就是把事件绑定在父级身上，只需要绑定一次，在触发子元素的时候，优化冒泡就会触发父元素的事件
  - **获取触发元素:**`event.taiget`

```
1.创建一个ul，内部有10个li元素，点击li元素的时候打印‘点击了li’
2.创建一个按钮，给按钮添加点击事件，并在事件内部，给ul动态添加li元素，且要让新添加的li元素有事件，
同样打印‘点击了li’
```

- **避开：**组织事件冒泡
  - **造成的影响:** 父级自己绑定相同的事件，但是在点击子级的时候，不喜欢父级的事件触发,但是由于事件冒泡会继续触发父级的事件
  - **阻止冒泡:**`event.stopPropagation()`

```
1.创建三个关系是子级、父级、爷爷级别的div元素
2.分别给这个三个元素添加点击事件且该事件是冒泡阶段
```



#### 8.3事件对象

- **描述**：事件发生后，跟事件相关的一系列信息数据的集合都放在这个对象里，这个对象就是事件对象

- event : 很多的属性和方法
  - 例子: 
    -  谁绑定了这个事件 、鼠标触发事件的话，
    - 会得到鼠标的相关信息，如鼠标位置、键盘触发事件的话，                          
    -  会得到键盘的相关信息，如按了哪个键
- **注：**`只有在事件执行程序中存在event对象`